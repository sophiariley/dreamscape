// Copyright Â© 2021-present 650 Industries, Inc. (aka Expo)

#include "JavaScriptValue.h"

#include "JavaScriptRuntime.h"
#include "JavaScriptObject.h"
<<<<<<< HEAD
<<<<<<< HEAD
#include "JavaScriptTypedArray.h"
#include "TypedArray.h"
#include "Exceptions.h"
=======
>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin

namespace expo {
void JavaScriptValue::registerNatives() {
  registerHybrid({
                   makeNativeMethod("kind", JavaScriptValue::jniKind),
                   makeNativeMethod("isNull", JavaScriptValue::isNull),
                   makeNativeMethod("isUndefined", JavaScriptValue::isUndefined),
                   makeNativeMethod("isBool", JavaScriptValue::isBool),
                   makeNativeMethod("isNumber", JavaScriptValue::isNumber),
                   makeNativeMethod("isString", JavaScriptValue::isString),
                   makeNativeMethod("isSymbol", JavaScriptValue::isSymbol),
                   makeNativeMethod("isFunction", JavaScriptValue::isFunction),
                   makeNativeMethod("isArray", JavaScriptValue::isArray),
<<<<<<< HEAD
<<<<<<< HEAD
                   makeNativeMethod("isTypedArray", JavaScriptValue::isTypedArray),
=======
>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
                   makeNativeMethod("isObject", JavaScriptValue::isObject),
                   makeNativeMethod("getBool", JavaScriptValue::getBool),
                   makeNativeMethod("getDouble", JavaScriptValue::getDouble),
                   makeNativeMethod("getString", JavaScriptValue::jniGetString),
                   makeNativeMethod("getObject", JavaScriptValue::getObject),
                   makeNativeMethod("getArray", JavaScriptValue::getArray),
<<<<<<< HEAD
<<<<<<< HEAD
                   makeNativeMethod("getTypedArray", JavaScriptValue::getTypedArray),
=======
>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
                 });
}

JavaScriptValue::JavaScriptValue(
  std::weak_ptr<JavaScriptRuntime> runtime,
  std::shared_ptr<jsi::Value> jsValue
) : runtimeHolder(std::move(runtime)), jsValue(std::move(jsValue)) {
<<<<<<< HEAD
<<<<<<< HEAD
  runtimeHolder.ensureRuntimeIsValid();
}

JavaScriptValue::JavaScriptValue(
  WeakRuntimeHolder runtime,
  std::shared_ptr<jsi::Value> jsValue
) : runtimeHolder(std::move(runtime)), jsValue(std::move(jsValue)) {
  runtimeHolder.ensureRuntimeIsValid();
=======
  assert(runtimeHolder.lock() != nullptr);
>>>>>>> origin/Sophia's-branch
=======
  assert(runtimeHolder.lock() != nullptr);
>>>>>>> origin
}

std::shared_ptr<jsi::Value> JavaScriptValue::get() {
  return jsValue;
}

std::string JavaScriptValue::kind() {
  if (isNull()) {
    return "null";
  }
  if (isUndefined()) {
    return "undefined";
  }
  if (isBool()) {
    return "boolean";
  }
  if (isNumber()) {
    return "number";
  }
  if (isString()) {
    return "string";
  }
  if (isSymbol()) {
    return "symbol";
  }
  if (isFunction()) {
    return "function";
  }
  if (isArray()) {
    return "array";
  }
  if (isObject()) {
    return "object";
  }

<<<<<<< HEAD
<<<<<<< HEAD
  throwNewJavaException(
    UnexpectedException::create("Unknown type").get()
  );
=======
  // TODO(@lukmccall): maybe throw exception?
  return "unknown";
>>>>>>> origin/Sophia's-branch
=======
  // TODO(@lukmccall): maybe throw exception?
  return "unknown";
>>>>>>> origin
}

bool JavaScriptValue::isNull() {
  return jsValue->isNull();
}

bool JavaScriptValue::isUndefined() {
  return jsValue->isUndefined();
}

bool JavaScriptValue::isBool() {
  return jsValue->isBool();
}

bool JavaScriptValue::isNumber() {
  return jsValue->isNumber();
}

bool JavaScriptValue::isString() {
  return jsValue->isString();
}

bool JavaScriptValue::isSymbol() {
  return jsValue->isSymbol();
}

bool JavaScriptValue::isFunction() {
  if (jsValue->isObject()) {
<<<<<<< HEAD
<<<<<<< HEAD
    auto &jsRuntime = runtimeHolder.getJSRuntime();
    return jsValue->asObject(jsRuntime).isFunction(jsRuntime);
=======
    auto runtime = runtimeHolder.lock();
    assert(runtime != nullptr);
    return jsValue->asObject(*runtime->get()).isFunction(*runtime->get());
>>>>>>> origin/Sophia's-branch
=======
    auto runtime = runtimeHolder.lock();
    assert(runtime != nullptr);
    return jsValue->asObject(*runtime->get()).isFunction(*runtime->get());
>>>>>>> origin
  }

  return false;
}

bool JavaScriptValue::isArray() {
  if (jsValue->isObject()) {
<<<<<<< HEAD
<<<<<<< HEAD
    auto &jsRuntime = runtimeHolder.getJSRuntime();
    return jsValue->asObject(jsRuntime).isArray(jsRuntime);
=======
    auto runtime = runtimeHolder.lock();
    assert(runtime != nullptr);
    return jsValue->asObject(*runtime->get()).isArray(*runtime->get());
>>>>>>> origin/Sophia's-branch
=======
    auto runtime = runtimeHolder.lock();
    assert(runtime != nullptr);
    return jsValue->asObject(*runtime->get()).isArray(*runtime->get());
>>>>>>> origin
  }

  return false;
}

bool JavaScriptValue::isObject() {
  return jsValue->isObject();
}

<<<<<<< HEAD
<<<<<<< HEAD
bool JavaScriptValue::isTypedArray() {
  if (jsValue->isObject()) {
    jsi::Runtime &jsRuntime = runtimeHolder.getJSRuntime();
    return expo::isTypedArray(jsRuntime, jsValue->getObject(jsRuntime));
  }
  return false;
}

=======
>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
bool JavaScriptValue::getBool() {
  return jsValue->getBool();
}

double JavaScriptValue::getDouble() {
  return jsValue->getNumber();
}

std::string JavaScriptValue::getString() {
<<<<<<< HEAD
<<<<<<< HEAD
  auto &jsRuntime = runtimeHolder.getJSRuntime();
  return jsValue->getString(jsRuntime).utf8(jsRuntime);
}

jni::local_ref<JavaScriptObject::javaobject> JavaScriptValue::getObject() {
  auto &jsRuntime = runtimeHolder.getJSRuntime();
  auto jsObject = std::make_shared<jsi::Object>(jsValue->getObject(jsRuntime));
=======
=======
>>>>>>> origin
  auto runtime = runtimeHolder.lock();
  assert(runtime != nullptr);
  return jsValue->getString(*runtime->get()).utf8(*runtime->get());
}

jni::local_ref<JavaScriptObject::javaobject> JavaScriptValue::getObject() {
  auto runtime = runtimeHolder.lock();
  assert(runtime != nullptr);
  auto jsObject = std::make_shared<jsi::Object>(jsValue->getObject(*runtime->get()));
<<<<<<< HEAD
>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
  return JavaScriptObject::newObjectCxxArgs(runtimeHolder, jsObject);
}

jni::local_ref<jni::JArrayClass<JavaScriptValue::javaobject>> JavaScriptValue::getArray() {
<<<<<<< HEAD
<<<<<<< HEAD
  auto &jsRuntime = runtimeHolder.getJSRuntime();

  auto jsArray = jsValue
    ->getObject(jsRuntime)
    .asArray(jsRuntime);
  size_t size = jsArray.size(jsRuntime);
=======
=======
>>>>>>> origin
  auto runtime = runtimeHolder.lock();
  assert(runtime != nullptr);

  auto jsArray = jsValue
    ->getObject(*runtime->get())
    .asArray(*runtime->get());
  size_t size = jsArray.size(*runtime->get());
<<<<<<< HEAD
>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin

  auto result = jni::JArrayClass<JavaScriptValue::javaobject>::newArray(size);
  for (size_t i = 0; i < size; i++) {
    auto element = JavaScriptValue::newObjectCxxArgs(
      runtimeHolder,
<<<<<<< HEAD
<<<<<<< HEAD
      std::make_shared<jsi::Value>(jsArray.getValueAtIndex(jsRuntime, i))
=======
      std::make_shared<jsi::Value>(jsArray.getValueAtIndex(*runtime->get(), i))
>>>>>>> origin/Sophia's-branch
=======
      std::make_shared<jsi::Value>(jsArray.getValueAtIndex(*runtime->get(), i))
>>>>>>> origin
    );

    result->setElement(i, element.release());
  }
  return result;
}

jni::local_ref<jstring> JavaScriptValue::jniKind() {
  auto result = kind();
  return jni::make_jstring(result);
}

jni::local_ref<jstring> JavaScriptValue::jniGetString() {
  auto result = getString();
  return jni::make_jstring(result);
}
<<<<<<< HEAD
<<<<<<< HEAD

jni::local_ref<JavaScriptTypedArray::javaobject> JavaScriptValue::getTypedArray() {
  auto &jsRuntime = runtimeHolder.getJSRuntime();
  auto jsObject = std::make_shared<jsi::Object>(jsValue->getObject(jsRuntime));
  return JavaScriptTypedArray::newObjectCxxArgs(runtimeHolder, jsObject);
}
=======
>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
} // namespace expo
