#include "MethodMetadata.h"
#include "JSIInteropModuleRegistry.h"
#include "JavaScriptValue.h"
#include "JavaScriptObject.h"
<<<<<<< HEAD
#include "JavaScriptTypedArray.h"
#include "JavaReferencesCache.h"
#include "Exceptions.h"
#include "JavaCallback.h"

#include <utility>

#include <react/jni/ReadableNativeMap.h>
#include <react/jni/ReadableNativeArray.h>
#include <react/jni/WritableNativeArray.h>
#include <react/jni/WritableNativeMap.h>
#include "JSReferencesCache.h"
=======
#include "CachedReferencesRegistry.h"

#include <utility>

#include "react/jni/ReadableNativeMap.h"
#include "react/jni/ReadableNativeArray.h"
>>>>>>> Sophia's-branch

namespace jni = facebook::jni;
namespace jsi = facebook::jsi;
namespace react = facebook::react;

namespace expo {

// Modified version of the RN implementation
// https://github.com/facebook/react-native/blob/7dceb9b63c0bfd5b13bf6d26f9530729506e9097/ReactCommon/react/nativemodule/core/platform/android/ReactCommon/JavaTurboModule.cpp#L57
<<<<<<< HEAD
jni::local_ref<JavaCallback::JavaPart> createJavaCallbackFromJSIFunction(
  jsi::Function &&function,
  std::weak_ptr<react::LongLivedObjectCollection> longLivedObjectCollection,
  jsi::Runtime &rt,
  JSIInteropModuleRegistry *moduleRegistry,
  bool isRejectCallback = false
) {
  std::shared_ptr<react::CallInvoker> jsInvoker = moduleRegistry->runtimeHolder->jsInvoker;
  auto strongLongLiveObjectCollection = longLivedObjectCollection.lock();
  if (!strongLongLiveObjectCollection) {
    throw std::runtime_error("The LongLivedObjectCollection for MethodMetadata is not alive.");
  }
  auto weakWrapper = react::CallbackWrapper::createWeak(strongLongLiveObjectCollection,
                                                        std::move(function), rt,
=======
jni::local_ref<react::JCxxCallbackImpl::JavaPart> createJavaCallbackFromJSIFunction(
  jsi::Function &&function,
  jsi::Runtime &rt,
  std::shared_ptr<react::CallInvoker> jsInvoker
) {
  auto weakWrapper = react::CallbackWrapper::createWeak(std::move(function), rt,
>>>>>>> Sophia's-branch
                                                        std::move(jsInvoker));

  // This needs to be a shared_ptr because:
  // 1. It cannot be unique_ptr. std::function is copyable but unique_ptr is
  // not.
  // 2. It cannot be weak_ptr since we need this object to live on.
  // 3. It cannot be a value, because that would be deleted as soon as this
  // function returns.
  auto callbackWrapperOwner =
    std::make_shared<react::RAIICallbackWrapperDestroyer>(weakWrapper);

  std::function<void(folly::dynamic)> fn =
<<<<<<< HEAD
    [
      weakWrapper,
      callbackWrapperOwner = std::move(callbackWrapperOwner),
      wrapperWasCalled = false,
      isRejectCallback
    ](
=======
    [weakWrapper, callbackWrapperOwner, wrapperWasCalled = false](
>>>>>>> Sophia's-branch
      folly::dynamic responses) mutable {
      if (wrapperWasCalled) {
        throw std::runtime_error(
          "callback 2 arg cannot be called more than once");
      }

      auto strongWrapper = weakWrapper.lock();
      if (!strongWrapper) {
        return;
      }

      strongWrapper->jsInvoker().invokeAsync(
<<<<<<< HEAD
        [
          weakWrapper,
          callbackWrapperOwner = std::move(callbackWrapperOwner),
          responses = std::move(responses),
          isRejectCallback
        ]() mutable {
=======
        [weakWrapper, callbackWrapperOwner, responses]() mutable {
>>>>>>> Sophia's-branch
          auto strongWrapper2 = weakWrapper.lock();
          if (!strongWrapper2) {
            return;
          }

<<<<<<< HEAD
          jsi::Value arg = jsi::valueFromDynamic(strongWrapper2->runtime(), responses);
          if (!isRejectCallback) {
            strongWrapper2->callback().call(
              strongWrapper2->runtime(),
              (const jsi::Value *) &arg,
              (size_t) 1
            );
          } else {
            auto &rt = strongWrapper2->runtime();
            auto jsErrorObject = arg.getObject(rt);
            auto errorCode = jsErrorObject.getProperty(rt, "code").asString(rt);
            auto message = jsErrorObject.getProperty(rt, "message").asString(rt);

            auto codedError = makeCodedError(
              rt,
              std::move(errorCode),
              std::move(message)
            );

            strongWrapper2->callback().call(
              strongWrapper2->runtime(),
              (const jsi::Value *) &codedError,
              (size_t) 1
            );
          }
=======
          jsi::Value args =
            jsi::valueFromDynamic(strongWrapper2->runtime(), responses);
          auto argsArray = args.getObject(strongWrapper2->runtime())
            .asArray(strongWrapper2->runtime());
          jsi::Value arg = argsArray.getValueAtIndex(strongWrapper2->runtime(), 0);

          strongWrapper2->callback().call(
            strongWrapper2->runtime(),
            (const jsi::Value *) &arg,
            (size_t) 1
          );
>>>>>>> Sophia's-branch

          callbackWrapperOwner.reset();
        });

      wrapperWasCalled = true;
    };

<<<<<<< HEAD
  return JavaCallback::newObjectCxxArgs(std::move(fn));
}

jobjectArray MethodMetadata::convertJSIArgsToJNI(
=======
  return react::JCxxCallbackImpl::newObjectCxxArgs(fn);
}

std::vector<jvalue> MethodMetadata::convertJSIArgsToJNI(
>>>>>>> Sophia's-branch
  JSIInteropModuleRegistry *moduleRegistry,
  JNIEnv *env,
  jsi::Runtime &rt,
  const jsi::Value *args,
<<<<<<< HEAD
  size_t count
) {
  auto argumentArray = env->NewObjectArray(
    count,
    JavaReferencesCache::instance()->getJClass("java/lang/Object").clazz,
    nullptr
  );

  std::vector<jobject> result(count);

  for (unsigned int argIndex = 0; argIndex < count; argIndex++) {
    const jsi::Value &arg = args[argIndex];
    auto &type = argTypes[argIndex];
    if (arg.isNull() || arg.isUndefined()) {
      // If value is null or undefined, we just passes a null
      // Kotlin code will check if expected type is nullable.
      result[argIndex] = nullptr;
    } else {
      if (type->converter->canConvert(rt, arg)) {
        auto converterValue = type->converter->convert(rt, env, moduleRegistry, arg);
        env->SetObjectArrayElement(argumentArray, argIndex, converterValue);
        env->DeleteLocalRef(converterValue);
      } else {
        auto stringRepresentation = arg.toString(rt).utf8(rt);
        throwNewJavaException(
          UnexpectedException::create(
            "Cannot convert '" + stringRepresentation + "' to a Kotlin type.").get()
        );
      }
    }
  }

  return argumentArray;
}

MethodMetadata::MethodMetadata(
  std::weak_ptr<react::LongLivedObjectCollection> longLivedObjectCollection,
  std::string name,
  int args,
  bool isAsync,
  jni::local_ref<jni::JArrayClass<ExpectedType>> expectedArgTypes,
=======
  size_t count,
  bool returnGlobalReferences
) {
  std::vector<jvalue> result(count);

  auto makeGlobalIfNecessary = [env, returnGlobalReferences](jobject obj) -> jobject {
    if (returnGlobalReferences) {
      return env->NewGlobalRef(obj);
    }
    return obj;
  };

  for (unsigned int argIndex = 0; argIndex < count; argIndex++) {
    const jsi::Value *arg = &args[argIndex];
    jvalue *jarg = &result[argIndex];
    int desiredType = desiredTypes[argIndex];

    if (desiredType & CppType::JS_VALUE) {
      jarg->l = makeGlobalIfNecessary(
        JavaScriptValue::newObjectCxxArgs(
          moduleRegistry->runtimeHolder->weak_from_this(),
          // TODO(@lukmccall): make sure that copy here is necessary
          std::make_shared<jsi::Value>(jsi::Value(rt, *arg))
        ).release()
      );
    } else if (desiredType & CppType::JS_OBJECT) {
      jarg->l = makeGlobalIfNecessary(
        JavaScriptObject::newObjectCxxArgs(
          moduleRegistry->runtimeHolder->weak_from_this(),
          std::make_shared<jsi::Object>(arg->getObject(rt))
        ).release()
      );
    } else if (arg->isNull() || arg->isUndefined()) {
      jarg->l = nullptr;
    } else if (arg->isNumber()) {
      auto &doubleClass = CachedReferencesRegistry::instance()
        ->getJClass("java/lang/Double");
      jmethodID doubleConstructor = doubleClass.getMethod("<init>", "(D)V");
      jarg->l = makeGlobalIfNecessary(
        env->NewObject(doubleClass.clazz, doubleConstructor, arg->getNumber()));
    } else if (arg->isBool()) {
      auto &booleanClass = CachedReferencesRegistry::instance()
        ->getJClass("java/lang/Boolean");
      jmethodID booleanConstructor = booleanClass.getMethod("<init>", "(Z)V");
      jarg->l = makeGlobalIfNecessary(
        env->NewObject(booleanClass.clazz, booleanConstructor, arg->getBool()));
    } else if (arg->isString()) {
      jarg->l = makeGlobalIfNecessary(env->NewStringUTF(arg->getString(rt).utf8(rt).c_str()));
    } else if (arg->isObject()) {
      const jsi::Object object = arg->getObject(rt);

      // TODO(@lukmccall): stop using dynamic
      auto dynamic = jsi::dynamicFromValue(rt, *arg);
      if (arg->getObject(rt).isArray(rt)) {
        jarg->l = makeGlobalIfNecessary(
          react::ReadableNativeArray::newObjectCxxArgs(std::move(dynamic)).release());
      } else {
        jarg->l = makeGlobalIfNecessary(
          react::ReadableNativeMap::createWithContents(std::move(dynamic)).release());
      }
    } else {
      // TODO(@lukmccall): throw an exception
      jarg->l = nullptr;
    }
  }

  return result;
}

MethodMetadata::MethodMetadata(
  std::string name,
  int args,
  bool isAsync,
  std::unique_ptr<int[]> desiredTypes,
>>>>>>> Sophia's-branch
  jni::global_ref<jobject> &&jBodyReference
) : name(std::move(name)),
    args(args),
    isAsync(isAsync),
<<<<<<< HEAD
    jBodyReference(std::move(jBodyReference)),
    longLivedObjectCollection_(longLivedObjectCollection) {
  argTypes.reserve(args);
  for (size_t i = 0; i < args; i++) {
    auto expectedType = expectedArgTypes->getElement(i);
    argTypes.push_back(
      std::make_unique<AnyType>(std::move(expectedType))
    );
  }
}

MethodMetadata::MethodMetadata(
  std::weak_ptr<react::LongLivedObjectCollection> longLivedObjectCollection,
  std::string name,
  int args,
  bool isAsync,
  std::vector<std::unique_ptr<AnyType>> &&expectedArgTypes,
  jni::global_ref<jobject> &&jBodyReference
) : name(std::move(name)),
    args(args),
    isAsync(isAsync),
    argTypes(std::move(expectedArgTypes)),
    jBodyReference(std::move(jBodyReference)),
    longLivedObjectCollection_(longLivedObjectCollection) {
}
=======
    desiredTypes(std::move(desiredTypes)),
    jBodyReference(std::move(jBodyReference)) {}
>>>>>>> Sophia's-branch

std::shared_ptr<jsi::Function> MethodMetadata::toJSFunction(
  jsi::Runtime &runtime,
  JSIInteropModuleRegistry *moduleRegistry
) {
  if (body == nullptr) {
    if (isAsync) {
      body = std::make_shared<jsi::Function>(toAsyncFunction(runtime, moduleRegistry));
    } else {
      body = std::make_shared<jsi::Function>(toSyncFunction(runtime, moduleRegistry));
    }
  }

  return body;
}

jsi::Function MethodMetadata::toSyncFunction(
  jsi::Runtime &runtime,
  JSIInteropModuleRegistry *moduleRegistry
) {
  return jsi::Function::createFromHostFunction(
    runtime,
<<<<<<< HEAD
    moduleRegistry->jsRegistry->getPropNameID(runtime, name),
=======
    jsi::PropNameID::forAscii(runtime, name),
>>>>>>> Sophia's-branch
    args,
    [this, moduleRegistry](
      jsi::Runtime &rt,
      const jsi::Value &thisValue,
      const jsi::Value *args,
      size_t count
    ) -> jsi::Value {
<<<<<<< HEAD
      try {
        return this->callSync(
          rt,
          moduleRegistry,
          args,
          count
        );
      } catch (jni::JniException &jniException) {
        rethrowAsCodedError(rt, jniException);
      }
=======
      return this->callSync(
        rt,
        moduleRegistry,
        args,
        count
      );
>>>>>>> Sophia's-branch
    });
}

jsi::Value MethodMetadata::callSync(
  jsi::Runtime &rt,
  JSIInteropModuleRegistry *moduleRegistry,
  const jsi::Value *args,
  size_t count
) {
  if (this->jBodyReference == nullptr) {
    return jsi::Value::undefined();
  }

  JNIEnv *env = jni::Environment::current();

  /**
   * This will push a new JNI stack frame for the LocalReferences in this
   * function call. When the stack frame for this lambda is popped,
   * all LocalReferences are deleted.
   */
  jni::JniLocalScope scope(env, (int) count);

<<<<<<< HEAD
  auto convertedArgs = convertJSIArgsToJNI(moduleRegistry, env, rt, args, count);
=======
  std::vector<jvalue> convertedArgs = convertJSIArgsToJNI(moduleRegistry, env, rt, args, count,
                                                          false);

  // TODO(@lukmccall): Remove this temp array
  auto tempArray = env->NewObjectArray(
    convertedArgs.size(),
    CachedReferencesRegistry::instance()->getJClass("java/lang/Object").clazz,
    nullptr
  );
  for (size_t i = 0; i < convertedArgs.size(); i++) {
    env->SetObjectArrayElement(tempArray, i, convertedArgs[i].l);
  }
>>>>>>> Sophia's-branch

  // Cast in this place is safe, cause we know that this function is promise-less.
  auto syncFunction = jni::static_ref_cast<JNIFunctionBody>(this->jBodyReference);
  auto result = syncFunction->invoke(
<<<<<<< HEAD
    convertedArgs
  );

  env->DeleteLocalRef(convertedArgs);
  if (result == nullptr) {
    return jsi::Value::undefined();
  }
  auto unpackedResult = result.get();
  auto cache = JavaReferencesCache::instance();
  if (env->IsInstanceOf(unpackedResult, cache->getJClass("java/lang/Double").clazz)) {
    return {jni::static_ref_cast<jni::JDouble>(result)->value()};
  }
  if (env->IsInstanceOf(unpackedResult, cache->getJClass("java/lang/Integer").clazz)) {
    return {jni::static_ref_cast<jni::JInteger>(result)->value()};
  }
  if (env->IsInstanceOf(unpackedResult, cache->getJClass("java/lang/String").clazz)) {
    return jsi::String::createFromUtf8(
      rt,
      jni::static_ref_cast<jni::JString>(result)->toStdString()
    );
  }
  if (env->IsInstanceOf(unpackedResult, cache->getJClass("java/lang/Boolean").clazz)) {
    return {(bool) jni::static_ref_cast<jni::JBoolean>(result)->value()};
  }
  if (env->IsInstanceOf(unpackedResult, cache->getJClass("java/lang/Float").clazz)) {
    return {(double) jni::static_ref_cast<jni::JFloat>(result)->value()};
  }
  if (env->IsInstanceOf(
    unpackedResult,
    cache->getJClass("com/facebook/react/bridge/WritableNativeArray").clazz
  )) {
    auto dynamic = jni::static_ref_cast<react::WritableNativeArray::javaobject>(result)
      ->cthis()
      ->consume();
    return jsi::valueFromDynamic(rt, dynamic);
  }
  if (env->IsInstanceOf(
    unpackedResult,
    cache->getJClass("com/facebook/react/bridge/WritableNativeMap").clazz
  )) {
    auto dynamic = jni::static_ref_cast<react::WritableNativeMap::javaobject>(result)
      ->cthis()
      ->consume();
    return jsi::valueFromDynamic(rt, dynamic);
  }

  return jsi::Value::undefined();
=======
    tempArray
  );

  if (result == nullptr) {
    return jsi::Value::undefined();
  }

  return jsi::valueFromDynamic(rt, result->cthis()->consume())
    .asObject(rt)
    .asArray(rt)
    .getValueAtIndex(rt, 0);
>>>>>>> Sophia's-branch
}

jsi::Function MethodMetadata::toAsyncFunction(
  jsi::Runtime &runtime,
  JSIInteropModuleRegistry *moduleRegistry
) {
  return jsi::Function::createFromHostFunction(
    runtime,
<<<<<<< HEAD
    moduleRegistry->jsRegistry->getPropNameID(runtime, name),
=======
    jsi::PropNameID::forAscii(runtime, name),
>>>>>>> Sophia's-branch
    args,
    [this, moduleRegistry](
      jsi::Runtime &rt,
      const jsi::Value &thisValue,
      const jsi::Value *args,
      size_t count
    ) -> jsi::Value {
      JNIEnv *env = jni::Environment::current();

      /**
       * This will push a new JNI stack frame for the LocalReferences in this
       * function call. When the stack frame for this lambda is popped,
       * all LocalReferences are deleted.
       */
      jni::JniLocalScope scope(env, (int) count);
<<<<<<< HEAD

      auto &Promise = moduleRegistry->jsRegistry->getObject<jsi::Function>(
        JSReferencesCache::JSKeys::PROMISE
      );

      try {
        auto convertedArgs = convertJSIArgsToJNI(moduleRegistry, env, rt, args, count);
        auto globalConvertedArgs = (jobjectArray) env->NewGlobalRef(convertedArgs);
        env->DeleteLocalRef(convertedArgs);

        // Creates a JSI promise
        jsi::Value promise = Promise.callAsConstructor(
          rt,
          createPromiseBody(rt, moduleRegistry, globalConvertedArgs)
        );
        return promise;
      } catch (jni::JniException &jniException) {
        jni::local_ref<jni::JThrowable> unboxedThrowable = jniException.getThrowable();
        if (!unboxedThrowable->isInstanceOf(CodedException::javaClassLocal())) {
          unboxedThrowable = UnexpectedException::create(jniException.what());
        }

        auto codedException = jni::static_ref_cast<CodedException>(unboxedThrowable);
        auto code = codedException->getCode();
        auto message = codedException->getLocalizedMessage().value_or("");

        jsi::Value promise = Promise.callAsConstructor(
          rt,
          jsi::Function::createFromHostFunction(
            rt,
            moduleRegistry->jsRegistry->getPropNameID(rt, "promiseFn"),
            2,
            [code, message](
              jsi::Runtime &rt,
              const jsi::Value &thisVal,
              const jsi::Value *promiseConstructorArgs,
              size_t promiseConstructorArgCount
            ) {
              if (promiseConstructorArgCount != 2) {
                throw std::invalid_argument("Promise fn arg count must be 2");
              }

              jsi::Function rejectJSIFn = promiseConstructorArgs[1].getObject(rt).getFunction(rt);
              rejectJSIFn.call(
                rt,
                makeCodedError(
                  rt,
                  jsi::String::createFromUtf8(rt, code),
                  jsi::String::createFromUtf8(rt, message)
                )
              );
              return jsi::Value::undefined();
            }
          )
        );

        return promise;
      }
=======
      std::vector<jvalue> convertedArgs = convertJSIArgsToJNI(moduleRegistry, env, rt, args, count,
                                                              true);

      auto Promise = rt.global().getPropertyAsFunction(rt, "Promise");
      // Creates a JSI promise
      jsi::Value promise = Promise.callAsConstructor(
        rt,
        createPromiseBody(rt, moduleRegistry, std::move(convertedArgs))
      );
      return promise;
>>>>>>> Sophia's-branch
    }
  );
}

jsi::Function MethodMetadata::createPromiseBody(
  jsi::Runtime &runtime,
  JSIInteropModuleRegistry *moduleRegistry,
<<<<<<< HEAD
  jobjectArray globalArgs
) {
  return jsi::Function::createFromHostFunction(
    runtime,
    moduleRegistry->jsRegistry->getPropNameID(runtime, "promiseFn"),
    2,
    [this, globalArgs, moduleRegistry](
=======
  std::vector<jvalue> &&args
) {
  return jsi::Function::createFromHostFunction(
    runtime,
    jsi::PropNameID::forAscii(runtime, "promiseFn"),
    2,
    [this, args = std::move(args), moduleRegistry](
>>>>>>> Sophia's-branch
      jsi::Runtime &rt,
      const jsi::Value &thisVal,
      const jsi::Value *promiseConstructorArgs,
      size_t promiseConstructorArgCount
    ) {
      if (promiseConstructorArgCount != 2) {
        throw std::invalid_argument("Promise fn arg count must be 2");
      }

      jsi::Function resolveJSIFn = promiseConstructorArgs[0].getObject(rt).getFunction(rt);
      jsi::Function rejectJSIFn = promiseConstructorArgs[1].getObject(rt).getFunction(rt);

<<<<<<< HEAD
      jobject resolve = createJavaCallbackFromJSIFunction(
        std::move(resolveJSIFn),
        longLivedObjectCollection_,
        rt,
        moduleRegistry
=======
      auto &runtimeHolder = moduleRegistry->runtimeHolder;
      jobject resolve = createJavaCallbackFromJSIFunction(
        std::move(resolveJSIFn),
        rt,
        runtimeHolder->jsInvoker
>>>>>>> Sophia's-branch
      ).release();

      jobject reject = createJavaCallbackFromJSIFunction(
        std::move(rejectJSIFn),
<<<<<<< HEAD
        longLivedObjectCollection_,
        rt,
        moduleRegistry,
        true
=======
        rt,
        runtimeHolder->jsInvoker
>>>>>>> Sophia's-branch
      ).release();

      JNIEnv *env = jni::Environment::current();

<<<<<<< HEAD
      auto &jPromise = JavaReferencesCache::instance()->getJClass(
        "expo/modules/kotlin/jni/PromiseImpl");
      jmethodID jPromiseConstructor = jPromise.getMethod(
        "<init>",
        "(Lexpo/modules/kotlin/jni/JavaCallback;Lexpo/modules/kotlin/jni/JavaCallback;)V"
=======
      auto &jPromise = CachedReferencesRegistry::instance()->getJClass(
        "com/facebook/react/bridge/PromiseImpl");
      jmethodID jPromiseConstructor = jPromise.getMethod(
        "<init>",
        "(Lcom/facebook/react/bridge/Callback;Lcom/facebook/react/bridge/Callback;)V"
>>>>>>> Sophia's-branch
      );

      // Creates a promise object
      jobject promise = env->NewObject(
        jPromise.clazz,
        jPromiseConstructor,
        resolve,
        reject
      );

<<<<<<< HEAD
      // Cast in this place is safe, cause we know that this function expects promise.
      auto asyncFunction = jni::static_ref_cast<JNIAsyncFunctionBody>(this->jBodyReference);
      asyncFunction->invoke(
        globalArgs,
=======
      auto argsSize = args.size();
      // TODO(@lukmccall): Remove this temp array
      auto tempArray = env->NewObjectArray(
        argsSize,
        CachedReferencesRegistry::instance()->getJClass("java/lang/Object").clazz,
        nullptr
      );
      for (size_t i = 0; i < argsSize; i++) {
        env->SetObjectArrayElement(tempArray, i, args[i].l);
      }

      // Cast in this place is safe, cause we know that this function expects promise.
      auto asyncFunction = jni::static_ref_cast<JNIAsyncFunctionBody>(this->jBodyReference);
      asyncFunction->invoke(
        tempArray,
>>>>>>> Sophia's-branch
        promise
      );

      // We have to remove the local reference to the promise object.
      // It doesn't mean that the promise will be deallocated, but rather that we move
      // the ownership to the `JNIAsyncFunctionBody`.
      env->DeleteLocalRef(promise);
<<<<<<< HEAD
      env->DeleteGlobalRef(globalArgs);
=======

      for (const auto &arg: args) {
        env->DeleteGlobalRef(arg.l);
      }
      env->DeleteLocalRef(tempArray);
>>>>>>> Sophia's-branch

      return jsi::Value::undefined();
    }
  );
}
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
} // namespace expo
