package expo.modules.kotlin.views

import android.content.Context
<<<<<<< HEAD
=======
import android.util.Log
>>>>>>> origin/Sophia's-branch
import android.view.View
import com.facebook.react.bridge.ReadableMap
import com.facebook.react.common.MapBuilder
import expo.modules.core.utilities.ifNull
import expo.modules.kotlin.ModuleHolder
<<<<<<< HEAD
import expo.modules.kotlin.events.normalizeEventName
import expo.modules.kotlin.logger
import expo.modules.kotlin.viewevent.ViewEventDelegate
=======
import expo.modules.kotlin.callbacks.ViewCallbackDelegate
>>>>>>> origin/Sophia's-branch
import kotlin.reflect.full.declaredMemberProperties
import kotlin.reflect.jvm.isAccessible

class ViewManagerWrapperDelegate(internal var moduleHolder: ModuleHolder) {
  private val definition: ViewManagerDefinition
    get() = requireNotNull(moduleHolder.definition.viewManagerDefinition)

  internal val viewGroupDefinition: ViewGroupDefinition?
    get() = definition.viewGroupDefinition

  val name: String
    get() = moduleHolder.name

  fun createView(context: Context): View {
    return definition
<<<<<<< HEAD
      .createView(context, moduleHolder.module.appContext)
=======
      .createView(context)
>>>>>>> origin/Sophia's-branch
      .also {
        configureView(it)
      }
  }

  fun setProxiedProperties(view: View, proxiedProperties: ReadableMap) {
    definition.setProps(proxiedProperties, view)
<<<<<<< HEAD
    definition.onViewDidUpdateProps?.invoke(view)
=======
>>>>>>> origin/Sophia's-branch
  }

  fun onDestroy(view: View) =
    definition.onViewDestroys?.invoke(view)

  fun getExportedCustomDirectEventTypeConstants(): Map<String, Any>? {
    val builder = MapBuilder.builder<String, Any>()
    definition
      .callbacksDefinition
      ?.names
      ?.forEach {
        builder.put(
<<<<<<< HEAD
          normalizeEventName(it), MapBuilder.of<String, Any>("registrationName", it)
=======
          it, MapBuilder.of<String, Any>("registrationName", it)
>>>>>>> origin/Sophia's-branch
        )
      }
    return builder.build()
  }

  private fun configureView(view: View) {
    val callbacks = definition.callbacksDefinition?.names ?: return

    val kClass = view.javaClass.kotlin
    val propertiesMap = kClass
      .declaredMemberProperties
<<<<<<< HEAD
      .associateBy { it.name }

    callbacks.forEach {
      val property = propertiesMap[it].ifNull {
        logger.warn("⚠️ Property `$it` does not exist in ${kClass.simpleName}")
=======
      .map { it.name to it }
      .toMap()

    callbacks.forEach {
      val property = propertiesMap[it].ifNull {
        Log.w("ExpoModuleCore", "Property `$it` does not exist in ${kClass.simpleName}.")
>>>>>>> origin/Sophia's-branch
        return@forEach
      }
      property.isAccessible = true

      val delegate = property.getDelegate(view).ifNull {
<<<<<<< HEAD
        logger.warn("⚠️ Property delegate for `$it` in ${kClass.simpleName} does not exist")
        return@forEach
      }

      val viewDelegate = (delegate as? ViewEventDelegate<*>).ifNull {
        logger.warn("⚠️ Property delegate for `$it` cannot be cased to `ViewCallbackDelegate`")
=======
        Log.w("ExpoModulesCore", "Property delegate for `$it` in ${kClass.simpleName} does not exist.")
        return@forEach
      }

      val viewDelegate = (delegate as? ViewCallbackDelegate<*>).ifNull {
        Log.w("ExpoModulesCore", "Property delegate for `$it` cannot be cased to `ViewCallbackDelegate`.")
>>>>>>> origin/Sophia's-branch
        return@forEach
      }

      viewDelegate.isValidated = true
    }
  }
}
