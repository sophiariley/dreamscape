package expo.modules.kotlin.functions

import com.facebook.react.bridge.ReadableArray
<<<<<<< HEAD
<<<<<<< HEAD
import expo.modules.kotlin.AppContext
=======
>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
import expo.modules.kotlin.ModuleHolder
import expo.modules.kotlin.Promise
import expo.modules.kotlin.exception.CodedException
import expo.modules.kotlin.exception.FunctionCallException
import expo.modules.kotlin.exception.UnexpectedException
import expo.modules.kotlin.exception.exceptionDecorator
<<<<<<< HEAD
<<<<<<< HEAD
import expo.modules.kotlin.jni.JavaScriptModuleObject
=======
>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
import expo.modules.kotlin.types.AnyType
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
>>>>>>> origin
import java.lang.ref.WeakReference

/**
 * We can't construct a `SuspendFunctionComponent` in the build phase, because it has to have access to module coroutine scope.
 * So we create another builder to store needed information and build it later - during the holder initialization.
 */
class SuspendFunctionComponentBuilder(
  internal val name: String,
  private val desiredArgsTypes: Array<AnyType>,
  private val body: suspend CoroutineScope.(args: Array<out Any?>) -> Any?,
) {
  fun build(moduleHolder: ModuleHolder) =
    SuspendFunctionComponent(name, desiredArgsTypes, WeakReference(moduleHolder), body)
}
<<<<<<< HEAD
>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin

class SuspendFunctionComponent(
  name: String,
  desiredArgsTypes: Array<AnyType>,
<<<<<<< HEAD
<<<<<<< HEAD
  private val body: suspend CoroutineScope.(args: Array<out Any?>) -> Any?
) : BaseAsyncFunctionComponent(name, desiredArgsTypes) {

  override fun call(holder: ModuleHolder, args: ReadableArray, promise: Promise) {
    val appContext = holder.module.appContext
    val queue = when (queue) {
      Queues.MAIN -> appContext.mainQueue
      Queues.DEFAULT -> appContext.modulesQueue
    }

    queue.launch {
      try {
        exceptionDecorator({
          FunctionCallException(name, holder.name, it)
        }) {
          val result = body.invoke(this, convertArgs(args))
          if (isActive) {
            promise.resolve(result)
          }
=======
=======
>>>>>>> origin
  private val moduleHolderRef: WeakReference<ModuleHolder>,
  private val body: suspend CoroutineScope.(args: Array<out Any?>) -> Any?
) : AsyncFunction(name, desiredArgsTypes) {
  @Throws(CodedException::class)
  override fun call(args: ReadableArray, promise: Promise) {
    callWithConvertedArguments(convertArgs(args), promise)
  }

  override fun call(args: Array<Any?>, promise: Promise) {
    callWithConvertedArguments(convertArgs(args), promise)
  }

  private fun callWithConvertedArguments(convertedArgs: Array<out Any?>, promise: Promise) {
    val holder = moduleHolderRef.get() ?: return
    val scope = holder.module.coroutineScopeDelegate.value

    scope.launch {
      try {
        val result = exceptionDecorator({ cause -> FunctionCallException(name, holder.name, cause) }) {
          body.invoke(scope, convertedArgs)
        }
        if (isActive) {
          promise.resolve(result)
<<<<<<< HEAD
>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
        }
      } catch (e: CodedException) {
        promise.reject(e)
      } catch (e: Throwable) {
        promise.reject(UnexpectedException(e))
      }
    }
  }
<<<<<<< HEAD
<<<<<<< HEAD

  override fun attachToJSObject(appContext: AppContext, jsObject: JavaScriptModuleObject) {
    jsObject.registerAsyncFunction(
      name,
      argsCount,
      desiredArgsTypes.map { it.getCppRequiredTypes() }.toTypedArray()
    ) { args, bridgePromise ->
      val queue = when (queue) {
        Queues.MAIN -> appContext.mainQueue
        Queues.DEFAULT -> appContext.modulesQueue
      }

      queue.launch {
        try {
          exceptionDecorator({
            FunctionCallException(name, jsObject.name, it)
          }) {
            val result = body.invoke(this, convertArgs(args))
            if (isActive) {
              bridgePromise.resolve(result)
            }
          }
        } catch (e: CodedException) {
          bridgePromise.reject(e)
        } catch (e: Throwable) {
          bridgePromise.reject(UnexpectedException(e))
        }
      }
    }
  }
=======
>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
}
