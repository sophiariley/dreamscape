/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 * @format
 */
<<<<<<< HEAD

'use strict';

const invariant = require('invariant');
const _require = require('../errors'),
  ParserError = _require.ParserError;
=======
'use strict';

const invariant = require('invariant');

const _require = require('../errors'),
  ParserError = _require.ParserError;

>>>>>>> Sophia's-branch
class MisnamedModuleFlowInterfaceParserError extends ParserError {
  constructor(hasteModuleName, id) {
    super(
      hasteModuleName,
      id,
      `All Flow interfaces extending TurboModule must be called 'Spec'. Please rename Flow interface '${id.name}' to 'Spec'.`,
    );
  }
}
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
class ModuleFlowInterfaceNotFoundParserError extends ParserError {
  constructor(hasteModuleName, ast) {
    super(
      hasteModuleName,
      ast,
      'No Flow interfaces extending TurboModule were detected in this NativeModule spec.',
    );
  }
}
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
class MoreThanOneModuleFlowInterfaceParserError extends ParserError {
  constructor(hasteModuleName, flowModuleInterfaces, names) {
    const finalName = names[names.length - 1];
    const allButLastName = names.slice(0, -1);
<<<<<<< HEAD
    const quote = x => `'${x}'`;
=======

    const quote = x => `'${x}'`;

>>>>>>> Sophia's-branch
    const nameStr =
      allButLastName.map(quote).join(', ') + ', and ' + quote(finalName);
    super(
      hasteModuleName,
      flowModuleInterfaces,
      `Every NativeModule spec file must declare exactly one NativeModule Flow interface. This file declares ${names.length}: ${nameStr}. Please remove the extraneous Flow interface declarations.`,
    );
  }
}
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
class UnsupportedModulePropertyParserError extends ParserError {
  constructor(
    hasteModuleName,
    propertyValue,
    propertyName,
    invalidPropertyValueType,
  ) {
    super(
      hasteModuleName,
      propertyValue,
      `Flow interfaces extending TurboModule must only contain 'FunctionTypeAnnotation's. Property '${propertyName}' refers to a '${invalidPropertyValueType}'.`,
    );
  }
}
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
class UnsupportedFlowTypeAnnotationParserError extends ParserError {
  constructor(hasteModuleName, typeAnnotation) {
    super(
      hasteModuleName,
      typeAnnotation,
      `Flow type annotation '${typeAnnotation.type}' is unsupported in NativeModule specs.`,
    );
    this.typeAnnotationType = typeAnnotation.type;
  }
}
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
class UnsupportedFlowGenericParserError extends ParserError {
  constructor(hasteModuleName, genericTypeAnnotation) {
    const genericName = genericTypeAnnotation.id.name;
    super(
      hasteModuleName,
      genericTypeAnnotation,
      `Unrecognized generic type '${genericName}' in NativeModule spec.`,
    );
    this.genericName = genericName;
  }
}
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
class IncorrectlyParameterizedFlowGenericParserError extends ParserError {
  constructor(hasteModuleName, genericTypeAnnotation) {
    if (genericTypeAnnotation.typeParameters == null) {
      super(
        hasteModuleName,
        genericTypeAnnotation,
        `Generic '${genericTypeAnnotation.id.name}' must have type parameters.`,
      );
      return;
    }
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
    if (
      genericTypeAnnotation.typeParameters.type ===
        'TypeParameterInstantiation' &&
      genericTypeAnnotation.typeParameters.params.length !== 1
    ) {
      super(
        hasteModuleName,
        genericTypeAnnotation.typeParameters,
        `Generic '${genericTypeAnnotation.id.name}' must have exactly one type parameter.`,
      );
      return;
    }
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
    invariant(
      false,
      "Couldn't create IncorrectlyParameterizedFlowGenericParserError",
    );
  }
}
<<<<<<< HEAD

=======
>>>>>>> Sophia's-branch
/**
 * Array parsing errors
 */

class UnsupportedArrayElementTypeAnnotationParserError extends ParserError {
  constructor(
    hasteModuleName,
    arrayElementTypeAST,
    arrayType,
    invalidArrayElementType,
  ) {
    super(
      hasteModuleName,
      arrayElementTypeAST,
      `${arrayType} element types cannot be '${invalidArrayElementType}'.`,
    );
  }
}
<<<<<<< HEAD

=======
>>>>>>> Sophia's-branch
/**
 * Object parsing errors
 */

class UnsupportedObjectPropertyTypeAnnotationParserError extends ParserError {
  constructor(hasteModuleName, propertyAST, invalidPropertyType) {
    let message = `'ObjectTypeAnnotation' cannot contain '${invalidPropertyType}'.`;
<<<<<<< HEAD
    if (invalidPropertyType === 'ObjectTypeSpreadProperty') {
      message = "Object spread isn't supported in 'ObjectTypeAnnotation's.";
    }
    super(hasteModuleName, propertyAST, message);
  }
}
=======

    if (invalidPropertyType === 'ObjectTypeSpreadProperty') {
      message = "Object spread isn't supported in 'ObjectTypeAnnotation's.";
    }

    super(hasteModuleName, propertyAST, message);
  }
}

>>>>>>> Sophia's-branch
class UnsupportedObjectPropertyValueTypeAnnotationParserError extends ParserError {
  constructor(
    hasteModuleName,
    propertyValueAST,
    propertyName,
    invalidPropertyValueType,
  ) {
    super(
      hasteModuleName,
      propertyValueAST,
      `Object property '${propertyName}' cannot have type '${invalidPropertyValueType}'.`,
    );
  }
}
<<<<<<< HEAD

=======
>>>>>>> Sophia's-branch
/**
 * Function parsing errors
 */

class UnnamedFunctionParamParserError extends ParserError {
  constructor(functionParam, hasteModuleName) {
    super(
      hasteModuleName,
      functionParam,
      'All function parameters must be named.',
    );
  }
}
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
class UnsupportedFunctionParamTypeAnnotationParserError extends ParserError {
  constructor(
    hasteModuleName,
    flowParamTypeAnnotation,
    paramName,
    invalidParamType,
  ) {
    super(
      hasteModuleName,
      flowParamTypeAnnotation,
      `Function parameter '${paramName}' cannot have type '${invalidParamType}'.`,
    );
  }
}
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
class UnsupportedFunctionReturnTypeAnnotationParserError extends ParserError {
  constructor(hasteModuleName, flowReturnTypeAnnotation, invalidReturnType) {
    super(
      hasteModuleName,
      flowReturnTypeAnnotation,
      `Function return cannot have type '${invalidReturnType}'.`,
    );
  }
}
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
class UnusedModuleFlowInterfaceParserError extends ParserError {
  constructor(hasteModuleName, flowInterface) {
    super(
      hasteModuleName,
      flowInterface,
      "Unused NativeModule spec. Please load the NativeModule by calling TurboModuleRegistry.get<Spec>('<moduleName>').",
    );
  }
}
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
class MoreThanOneModuleRegistryCallsParserError extends ParserError {
  constructor(hasteModuleName, flowCallExpressions, numCalls) {
    super(
      hasteModuleName,
      flowCallExpressions,
      `Every NativeModule spec file must contain exactly one NativeModule load. This file contains ${numCalls}. Please simplify this spec file, splitting it as necessary, to remove the extraneous loads.`,
    );
  }
}
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
class UntypedModuleRegistryCallParserError extends ParserError {
  constructor(hasteModuleName, flowCallExpression, methodName, moduleName) {
    super(
      hasteModuleName,
      flowCallExpression,
      `Please type this NativeModule load: TurboModuleRegistry.${methodName}<Spec>('${moduleName}').`,
    );
  }
}
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
class IncorrectModuleRegistryCallTypeParameterParserError extends ParserError {
  constructor(hasteModuleName, flowTypeArguments, methodName, moduleName) {
    super(
      hasteModuleName,
      flowTypeArguments,
      `Please change these type arguments to reflect TurboModuleRegistry.${methodName}<Spec>('${moduleName}').`,
    );
  }
}
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
class IncorrectModuleRegistryCallArityParserError extends ParserError {
  constructor(hasteModuleName, flowCallExpression, methodName, incorrectArity) {
    super(
      hasteModuleName,
      flowCallExpression,
      `Please call TurboModuleRegistry.${methodName}<Spec>() with exactly one argument. Detected ${incorrectArity}.`,
    );
  }
}
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
class IncorrectModuleRegistryCallArgumentTypeParserError extends ParserError {
  constructor(hasteModuleName, flowArgument, methodName, type) {
    const a = /[aeiouy]/.test(type.toLowerCase()) ? 'an' : 'a';
    super(
      hasteModuleName,
      flowArgument,
      `Please call TurboModuleRegistry.${methodName}<Spec>() with a string literal. Detected ${a} '${type}'`,
    );
  }
}
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
module.exports = {
  IncorrectlyParameterizedFlowGenericParserError,
  MisnamedModuleFlowInterfaceParserError,
  ModuleFlowInterfaceNotFoundParserError,
  MoreThanOneModuleFlowInterfaceParserError,
  UnnamedFunctionParamParserError,
  UnsupportedArrayElementTypeAnnotationParserError,
  UnsupportedFlowGenericParserError,
  UnsupportedFlowTypeAnnotationParserError,
  UnsupportedFunctionParamTypeAnnotationParserError,
  UnsupportedFunctionReturnTypeAnnotationParserError,
  UnsupportedModulePropertyParserError,
  UnsupportedObjectPropertyTypeAnnotationParserError,
  UnsupportedObjectPropertyValueTypeAnnotationParserError,
  UnusedModuleFlowInterfaceParserError,
  MoreThanOneModuleRegistryCallsParserError,
  UntypedModuleRegistryCallParserError,
  IncorrectModuleRegistryCallTypeParameterParserError,
  IncorrectModuleRegistryCallArityParserError,
  IncorrectModuleRegistryCallArgumentTypeParserError,
};
