/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 * @format
 */
<<<<<<< HEAD

=======
>>>>>>> Sophia's-branch
'use strict';

const _require = require('../../Utils'),
  capitalize = _require.capitalize;
<<<<<<< HEAD
function toJavaType(typeAnnotation, addImport) {
  const importNullable = () => addImport('androidx.annotation.Nullable');
  const importReadableMap = () =>
    addImport('com.facebook.react.bridge.ReadableMap');
  const importArrayList = () => addImport('java.util.ArrayList');
=======

function toJavaType(typeAnnotation, addImport) {
  const importNullable = () => addImport('androidx.annotation.Nullable');

  const importReadableMap = () =>
    addImport('com.facebook.react.bridge.ReadableMap');

  const importArrayList = () => addImport('java.util.ArrayList');

>>>>>>> Sophia's-branch
  switch (typeAnnotation.type) {
    /**
     * Primitives
     */
    case 'BooleanTypeAnnotation': {
      if (typeAnnotation.default === null) {
        importNullable();
        return '@Nullable Boolean';
      } else {
        return 'boolean';
      }
    }
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
    case 'StringTypeAnnotation': {
      importNullable();
      return '@Nullable String';
    }
<<<<<<< HEAD
    case 'DoubleTypeAnnotation': {
      return 'double';
    }
=======

    case 'DoubleTypeAnnotation': {
      return 'double';
    }

>>>>>>> Sophia's-branch
    case 'FloatTypeAnnotation': {
      if (typeAnnotation.default === null) {
        importNullable();
        return '@Nullable Float';
      } else {
        return 'float';
      }
    }
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
    case 'Int32TypeAnnotation': {
      return 'int';
    }

    /**
     * Enums
     */
    // TODO: Make StringEnumTypeAnnotation type-safe?
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
    case 'StringEnumTypeAnnotation':
      importNullable();
      return '@Nullable String';
    // TODO: Make Int32EnumTypeAnnotation type-safe?
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
    case 'Int32EnumTypeAnnotation':
      importNullable();
      return '@Nullable Integer';

    /**
     * Reserved types
     */
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
    case 'ReservedPropTypeAnnotation': {
      switch (typeAnnotation.name) {
        case 'ColorPrimitive':
          importNullable();
          return '@Nullable Integer';
<<<<<<< HEAD

        // TODO: Make ImageSourcePrimitive type-safe
=======
        // TODO: Make ImageSourcePrimitive type-safe

>>>>>>> Sophia's-branch
        case 'ImageSourcePrimitive':
          importNullable();
          importReadableMap();
          return '@Nullable ReadableMap';
<<<<<<< HEAD

        // TODO: Make PointPrimitive type-safe
=======
        // TODO: Make PointPrimitive type-safe

>>>>>>> Sophia's-branch
        case 'PointPrimitive':
          importNullable();
          importReadableMap();
          return '@Nullable ReadableMap';
<<<<<<< HEAD

        // TODO: Make EdgeInsetsPrimitive type-safe
=======
        // TODO: Make EdgeInsetsPrimitive type-safe

>>>>>>> Sophia's-branch
        case 'EdgeInsetsPrimitive':
          importNullable();
          importReadableMap();
          return '@Nullable ReadableMap';
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
        default:
          typeAnnotation.name;
          throw new Error(
            `Received unknown ReservedPropTypeAnnotation ${typeAnnotation.name}`,
          );
      }
    }

    /**
     * Other Pojo objects
     */
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
    case 'PojoTypeAliasTypeAnnotation': {
      return typeAnnotation.name;
    }

    /**
     * Arrays
     */
<<<<<<< HEAD
    case 'ArrayTypeAnnotation': {
      const elementType = typeAnnotation.elementType;
=======

    case 'ArrayTypeAnnotation': {
      const elementType = typeAnnotation.elementType;

>>>>>>> Sophia's-branch
      const elementTypeString = (() => {
        switch (elementType.type) {
          /**
           * Primitives
           */
          case 'BooleanTypeAnnotation': {
            return 'Boolean';
          }
<<<<<<< HEAD
          case 'StringTypeAnnotation': {
            return 'String';
          }
          case 'DoubleTypeAnnotation': {
            return 'Double';
          }
          case 'FloatTypeAnnotation': {
            return 'Float';
          }
=======

          case 'StringTypeAnnotation': {
            return 'String';
          }

          case 'DoubleTypeAnnotation': {
            return 'Double';
          }

          case 'FloatTypeAnnotation': {
            return 'Float';
          }

>>>>>>> Sophia's-branch
          case 'Int32TypeAnnotation': {
            return 'Integer';
          }

          /**
           * Enums
           */
          // TODO: Make StringEnums type-safe in Pojos
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
          case 'StringEnumTypeAnnotation': {
            return 'String';
          }

          /**
           * Other Pojo objects
           */
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
          case 'PojoTypeAliasTypeAnnotation': {
            return elementType.name;
          }

          /**
           * Reserved types
           */
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
          case 'ReservedPropTypeAnnotation': {
            switch (elementType.name) {
              case 'ColorPrimitive':
                return 'Integer';
<<<<<<< HEAD

              // TODO: Make ImageSourcePrimitive type-safe
              case 'ImageSourcePrimitive':
                importReadableMap();
                return 'ReadableMap';

              // TODO: Make PointPrimitive type-safe
              case 'PointPrimitive':
                importReadableMap();
                return 'ReadableMap';

              // TODO: Make EdgeInsetsPrimitive type-safe
              case 'EdgeInsetsPrimitive':
                importReadableMap();
                return 'ReadableMap';
=======
              // TODO: Make ImageSourcePrimitive type-safe

              case 'ImageSourcePrimitive':
                importReadableMap();
                return 'ReadableMap';
              // TODO: Make PointPrimitive type-safe

              case 'PointPrimitive':
                importReadableMap();
                return 'ReadableMap';
              // TODO: Make EdgeInsetsPrimitive type-safe

              case 'EdgeInsetsPrimitive':
                importReadableMap();
                return 'ReadableMap';

>>>>>>> Sophia's-branch
              default:
                elementType.name;
                throw new Error(
                  `Received unknown ReservedPropTypeAnnotation ${elementType.name}`,
                );
            }
          }
<<<<<<< HEAD

          // Arrays
=======
          // Arrays

>>>>>>> Sophia's-branch
          case 'ArrayTypeAnnotation': {
            const pojoTypeAliasTypeAnnotation = elementType.elementType;
            importArrayList();
            return `ArrayList<${pojoTypeAliasTypeAnnotation.name}>`;
          }
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
          default: {
            elementType.type;
            throw new Error(
              `Unrecognized PojoTypeAnnotation Array element type annotation '${typeAnnotation.type}'`,
            );
          }
        }
      })();
<<<<<<< HEAD
      importArrayList();
      return `ArrayList<${elementTypeString}>`;
    }
=======

      importArrayList();
      return `ArrayList<${elementTypeString}>`;
    }

>>>>>>> Sophia's-branch
    default: {
      typeAnnotation.type;
      throw new Error(
        `Unrecognized PojoTypeAnnotation '${typeAnnotation.type}'`,
      );
    }
  }
}
<<<<<<< HEAD
function toJavaMemberName(property) {
  return `m${capitalize(property.name)}`;
}
=======

function toJavaMemberName(property) {
  return `m${capitalize(property.name)}`;
}

>>>>>>> Sophia's-branch
function toJavaMemberDeclaration(property, addImport) {
  const type = toJavaType(property.typeAnnotation, addImport);
  const memberName = toJavaMemberName(property);
  return `private ${type} ${memberName};`;
}
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
function toJavaGetter(property, addImport) {
  const type = toJavaType(property.typeAnnotation, addImport);
  const getterName = `get${capitalize(property.name)}`;
  const memberName = toJavaMemberName(property);
  addImport('com.facebook.proguard.annotations.DoNotStrip');
  return `@DoNotStrip
public ${type} ${getterName}() {
  return ${memberName};
}`;
}
<<<<<<< HEAD
function serializePojo(pojo, basePackageName) {
  const importSet = new Set();
  const addImport = $import => {
    importSet.add($import);
  };
=======

function serializePojo(pojo, basePackageName) {
  const importSet = new Set();

  const addImport = $import => {
    importSet.add($import);
  };

>>>>>>> Sophia's-branch
  addImport('com.facebook.proguard.annotations.DoNotStrip');
  const indent = ' '.repeat(2);
  const members = pojo.properties
    .map(property => toJavaMemberDeclaration(property, addImport))
    .map(member => `${indent}${member}`)
    .join('\n');
  const getters = pojo.properties
    .map(property => toJavaGetter(property, addImport))
    .map(getter =>
      getter
        .split('\n')
        .map(line => `${indent}${line}`)
        .join('\n'),
    )
    .join('\n');
  const imports = [...importSet]
    .map($import => `import ${$import};`)
    .sort()
    .join('\n');
  return `/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* ${'@'}generated by codegen project: GeneratePropsJavaPojo.js
*/

package ${basePackageName}.${pojo.namespace};
${imports === '' ? '' : `\n${imports}\n`}
@DoNotStrip
public class ${pojo.name} {
${members}
${getters}
}
`;
}
<<<<<<< HEAD
=======

>>>>>>> Sophia's-branch
module.exports = {
  serializePojo,
};
