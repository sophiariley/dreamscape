/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 * @format
 */
<<<<<<< HEAD
<<<<<<< HEAD

=======
>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
'use strict';

function upperCaseFirst(inString) {
  if (inString.length === 0) {
    return inString;
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  return inString[0].toUpperCase() + inString.slice(1);
}
function toSafeCppString(input) {
  return input.split('-').map(upperCaseFirst).join('');
}
function toIntEnumValueName(propName, value) {
  return `${toSafeCppString(propName)}${value}`;
}
=======

<<<<<<< HEAD
  return inString[0].toUpperCase() + inString.slice(1);
}

function toSafeCppString(input) {
  return input.split('-').map(upperCaseFirst).join('');
}

function toIntEnumValueName(propName, value) {
  return `${toSafeCppString(propName)}${value}`;
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function getCppTypeForAnnotation(type) {
  switch (type) {
    case 'BooleanTypeAnnotation':
      return 'bool';
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
    case 'StringTypeAnnotation':
      return 'std::string';
    case 'Int32TypeAnnotation':
      return 'int';
    case 'DoubleTypeAnnotation':
      return 'double';
    case 'FloatTypeAnnotation':
      return 'Float';
=======

<<<<<<< HEAD
    case 'StringTypeAnnotation':
      return 'std::string';

    case 'Int32TypeAnnotation':
      return 'int';

    case 'DoubleTypeAnnotation':
      return 'double';

    case 'FloatTypeAnnotation':
      return 'Float';

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
    default:
      type;
      throw new Error(`Received invalid typeAnnotation ${type}`);
  }
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
function getImports(properties) {
  const imports = new Set();
=======

<<<<<<< HEAD
function getImports(properties) {
  const imports = new Set();

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
  function addImportsForNativeName(name) {
    switch (name) {
      case 'ColorPrimitive':
        return;
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
      case 'PointPrimitive':
        return;
      case 'EdgeInsetsPrimitive':
        return;
      case 'ImageSourcePrimitive':
        imports.add('#include <react/renderer/components/image/conversions.h>');
        return;
=======

<<<<<<< HEAD
      case 'PointPrimitive':
        return;

      case 'EdgeInsetsPrimitive':
        return;

      case 'ImageSourcePrimitive':
        imports.add('#include <react/renderer/components/image/conversions.h>');
        return;

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
      default:
        name;
        throw new Error(`Invalid name, got ${name}`);
    }
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  properties.forEach(prop => {
    const typeAnnotation = prop.typeAnnotation;
    if (typeAnnotation.type === 'ReservedPropTypeAnnotation') {
      addImportsForNativeName(typeAnnotation.name);
    }
=======

<<<<<<< HEAD
  properties.forEach(prop => {
    const typeAnnotation = prop.typeAnnotation;

    if (typeAnnotation.type === 'ReservedPropTypeAnnotation') {
      addImportsForNativeName(typeAnnotation.name);
    }

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
    if (
      typeAnnotation.type === 'ArrayTypeAnnotation' &&
      typeAnnotation.elementType.type === 'ReservedPropTypeAnnotation'
    ) {
      addImportsForNativeName(typeAnnotation.elementType.name);
    }
<<<<<<< HEAD
<<<<<<< HEAD
    if (typeAnnotation.type === 'ObjectTypeAnnotation') {
      const objectImports = getImports(typeAnnotation.properties);
      // $FlowFixMe[method-unbinding] added when improving typing for this parameters
=======
=======
>>>>>>> origin

    if (typeAnnotation.type === 'ObjectTypeAnnotation') {
      const objectImports = getImports(typeAnnotation.properties); // $FlowFixMe[method-unbinding] added when improving typing for this parameters

<<<<<<< HEAD
>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
      objectImports.forEach(imports.add, imports);
    }
  });
  return imports;
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function generateEventStructName(parts = []) {
  const additional = parts.map(toSafeCppString).join('');
  return `${additional}`;
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function generateStructName(componentName, parts = []) {
  const additional = parts.map(toSafeCppString).join('');
  return `${componentName}${additional}Struct`;
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function getEnumName(componentName, propName) {
  const uppercasedPropName = toSafeCppString(propName);
  return `${componentName}${uppercasedPropName}`;
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
function getEnumMaskName(enumName) {
  return `${enumName}Mask`;
}
function convertDefaultTypeToString(componentName, prop) {
  const typeAnnotation = prop.typeAnnotation;
=======

<<<<<<< HEAD
function getEnumMaskName(enumName) {
  return `${enumName}Mask`;
}

function convertDefaultTypeToString(componentName, prop) {
  const typeAnnotation = prop.typeAnnotation;

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
  switch (typeAnnotation.type) {
    case 'BooleanTypeAnnotation':
      if (typeAnnotation.default == null) {
        return '';
      }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
      return String(typeAnnotation.default);
=======

<<<<<<< HEAD
      return String(typeAnnotation.default);

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
    case 'StringTypeAnnotation':
      if (typeAnnotation.default == null) {
        return '';
      }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
      return `"${typeAnnotation.default}"`;
    case 'Int32TypeAnnotation':
      return String(typeAnnotation.default);
=======

<<<<<<< HEAD
      return `"${typeAnnotation.default}"`;

    case 'Int32TypeAnnotation':
      return String(typeAnnotation.default);

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
    case 'DoubleTypeAnnotation':
      const defaultDoubleVal = typeAnnotation.default;
      return parseInt(defaultDoubleVal, 10) === defaultDoubleVal
        ? typeAnnotation.default.toFixed(1)
        : String(typeAnnotation.default);
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
    case 'FloatTypeAnnotation':
      const defaultFloatVal = typeAnnotation.default;
      if (defaultFloatVal == null) {
        return '';
      }
      return parseInt(defaultFloatVal, 10) === defaultFloatVal
        ? defaultFloatVal.toFixed(1)
        : String(typeAnnotation.default);
=======

<<<<<<< HEAD
    case 'FloatTypeAnnotation':
      const defaultFloatVal = typeAnnotation.default;

      if (defaultFloatVal == null) {
        return '';
      }

      return parseInt(defaultFloatVal, 10) === defaultFloatVal
        ? defaultFloatVal.toFixed(1)
        : String(typeAnnotation.default);

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
    case 'ReservedPropTypeAnnotation':
      switch (typeAnnotation.name) {
        case 'ColorPrimitive':
          return '';
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
        case 'ImageSourcePrimitive':
          return '';
        case 'PointPrimitive':
          return '';
        case 'EdgeInsetsPrimitive':
          return '';
=======

<<<<<<< HEAD
        case 'ImageSourcePrimitive':
          return '';

        case 'PointPrimitive':
          return '';

        case 'EdgeInsetsPrimitive':
          return '';

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
        default:
          typeAnnotation.name;
          throw new Error(
            `Unsupported type annotation: ${typeAnnotation.name}`,
          );
      }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
    case 'ArrayTypeAnnotation': {
      const elementType = typeAnnotation.elementType;
=======

<<<<<<< HEAD
    case 'ArrayTypeAnnotation': {
      const elementType = typeAnnotation.elementType;

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
      switch (elementType.type) {
        case 'StringEnumTypeAnnotation':
          if (elementType.default == null) {
            throw new Error(
              'A default is required for array StringEnumTypeAnnotation',
            );
          }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
          const enumName = getEnumName(componentName, prop.name);
          const enumMaskName = getEnumMaskName(enumName);
          const defaultValue = `${enumName}::${toSafeCppString(
            elementType.default,
          )}`;
          return `static_cast<${enumMaskName}>(${defaultValue})`;
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
        default:
          return '';
      }
    }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
    case 'ObjectTypeAnnotation': {
      return '';
    }
=======

<<<<<<< HEAD
    case 'ObjectTypeAnnotation': {
      return '';
    }

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
    case 'StringEnumTypeAnnotation':
      return `${getEnumName(componentName, prop.name)}::${toSafeCppString(
        typeAnnotation.default,
      )}`;
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
    case 'Int32EnumTypeAnnotation':
      return `${getEnumName(componentName, prop.name)}::${toIntEnumValueName(
        prop.name,
        typeAnnotation.default,
      )}`;
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
    default:
      typeAnnotation;
      throw new Error(`Unsupported type annotation: ${typeAnnotation.type}`);
  }
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
module.exports = {
  convertDefaultTypeToString,
  getCppTypeForAnnotation,
  getEnumName,
  getEnumMaskName,
  getImports,
  toSafeCppString,
  toIntEnumValueName,
  generateStructName,
  generateEventStructName,
};
