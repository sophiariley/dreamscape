/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 * @format
 */
<<<<<<< HEAD

'use strict';

=======
'use strict';
>>>>>>> origin/Sophia's-branch
/*
TODO:

- ViewConfigs should spread in View's valid attributes
*/
<<<<<<< HEAD
const fs = require('fs');
const generateComponentDescriptorH = require('./components/GenerateComponentDescriptorH.js');
const generateComponentHObjCpp = require('./components/GenerateComponentHObjCpp.js');
const generateEventEmitterCpp = require('./components/GenerateEventEmitterCpp.js');
const generateEventEmitterH = require('./components/GenerateEventEmitterH.js');
const generatePropsCpp = require('./components/GeneratePropsCpp.js');
const generatePropsH = require('./components/GeneratePropsH.js');
const generateModuleH = require('./modules/GenerateModuleH.js');
const generateModuleCpp = require('./modules/GenerateModuleCpp.js');
const generateModuleObjCpp = require('./modules/GenerateModuleObjCpp');
const generateModuleJavaSpec = require('./modules/GenerateModuleJavaSpec.js');
const GenerateModuleJniCpp = require('./modules/GenerateModuleJniCpp.js');
const GenerateModuleJniH = require('./modules/GenerateModuleJniH.js');
const generatePropsJavaInterface = require('./components/GeneratePropsJavaInterface.js');
const generatePropsJavaDelegate = require('./components/GeneratePropsJavaDelegate.js');
const generateTests = require('./components/GenerateTests.js');
const generateShadowNodeCpp = require('./components/GenerateShadowNodeCpp.js');
const generateShadowNodeH = require('./components/GenerateShadowNodeH.js');
const generateThirdPartyFabricComponentsProviderObjCpp = require('./components/GenerateThirdPartyFabricComponentsProviderObjCpp.js');
const generateThirdPartyFabricComponentsProviderH = require('./components/GenerateThirdPartyFabricComponentsProviderH.js');
const generateViewConfigJs = require('./components/GenerateViewConfigJs.js');
const path = require('path');
const schemaValidator = require('../SchemaValidator.js');
=======

const fs = require('fs');

const generateComponentDescriptorH = require('./components/GenerateComponentDescriptorH.js');

const generateComponentHObjCpp = require('./components/GenerateComponentHObjCpp.js');

const generateEventEmitterCpp = require('./components/GenerateEventEmitterCpp.js');

const generateEventEmitterH = require('./components/GenerateEventEmitterH.js');

const generatePropsCpp = require('./components/GeneratePropsCpp.js');

const generatePropsH = require('./components/GeneratePropsH.js');

const generateModuleH = require('./modules/GenerateModuleH.js');

const generateModuleCpp = require('./modules/GenerateModuleCpp.js');

const generateModuleObjCpp = require('./modules/GenerateModuleObjCpp');

const generateModuleJavaSpec = require('./modules/GenerateModuleJavaSpec.js');

const GenerateModuleJniCpp = require('./modules/GenerateModuleJniCpp.js');

const GenerateModuleJniH = require('./modules/GenerateModuleJniH.js');

const generatePropsJavaInterface = require('./components/GeneratePropsJavaInterface.js');

const generatePropsJavaDelegate = require('./components/GeneratePropsJavaDelegate.js');

const generateTests = require('./components/GenerateTests.js');

const generateShadowNodeCpp = require('./components/GenerateShadowNodeCpp.js');

const generateShadowNodeH = require('./components/GenerateShadowNodeH.js');

const generateThirdPartyFabricComponentsProviderObjCpp = require('./components/GenerateThirdPartyFabricComponentsProviderObjCpp.js');

const generateThirdPartyFabricComponentsProviderH = require('./components/GenerateThirdPartyFabricComponentsProviderH.js');

const generateViewConfigJs = require('./components/GenerateViewConfigJs.js');

const path = require('path');

const schemaValidator = require('../SchemaValidator.js');

>>>>>>> origin/Sophia's-branch
const LIBRARY_GENERATORS = {
  descriptors: [generateComponentDescriptorH.generate],
  events: [generateEventEmitterCpp.generate, generateEventEmitterH.generate],
  props: [
    generateComponentHObjCpp.generate,
    generatePropsCpp.generate,
    generatePropsH.generate,
    generatePropsJavaInterface.generate,
    generatePropsJavaDelegate.generate,
  ],
  // TODO: Refactor this to consolidate various C++ output variation instead of forking per platform.
  componentsAndroid: [
    // JNI/C++ files
    generateComponentDescriptorH.generate,
    generateEventEmitterCpp.generate,
    generateEventEmitterH.generate,
    generatePropsCpp.generate,
    generatePropsH.generate,
    generateShadowNodeCpp.generate,
<<<<<<< HEAD
    generateShadowNodeH.generate,
    // Java files
=======
    generateShadowNodeH.generate, // Java files
>>>>>>> origin/Sophia's-branch
    generatePropsJavaInterface.generate,
    generatePropsJavaDelegate.generate,
  ],
  componentsIOS: [
    generateComponentDescriptorH.generate,
    generateEventEmitterCpp.generate,
    generateEventEmitterH.generate,
    generateComponentHObjCpp.generate,
    generatePropsCpp.generate,
    generatePropsH.generate,
    generateShadowNodeCpp.generate,
    generateShadowNodeH.generate,
  ],
  modulesAndroid: [
    GenerateModuleJniCpp.generate,
    GenerateModuleJniH.generate,
    generateModuleJavaSpec.generate,
  ],
  modulesCxx: [generateModuleCpp.generate, generateModuleH.generate],
  modulesIOS: [generateModuleObjCpp.generate],
  tests: [generateTests.generate],
  'shadow-nodes': [
    generateShadowNodeCpp.generate,
    generateShadowNodeH.generate,
  ],
};
const SCHEMAS_GENERATORS = {
  providerIOS: [
    generateThirdPartyFabricComponentsProviderObjCpp.generate,
    generateThirdPartyFabricComponentsProviderH.generate,
  ],
};
<<<<<<< HEAD
function writeMapToFiles(map) {
  let success = true;
  map.forEach(file => {
    try {
      const location = path.join(file.outputDir, file.name);
      const dirName = path.dirname(location);
=======

function writeMapToFiles(map, outputDir) {
  let success = true;
  map.forEach((contents, fileName) => {
    try {
      const location = path.join(outputDir, fileName);
      const dirName = path.dirname(location);

>>>>>>> origin/Sophia's-branch
      if (!fs.existsSync(dirName)) {
        fs.mkdirSync(dirName, {
          recursive: true,
        });
      }
<<<<<<< HEAD
      fs.writeFileSync(location, file.content);
    } catch (error) {
      success = false;
      console.error(`Failed to write ${file.name} to ${file.outputDir}`, error);
=======

      fs.writeFileSync(location, contents);
    } catch (error) {
      success = false;
      console.error(`Failed to write ${fileName} to ${outputDir}`, error);
>>>>>>> origin/Sophia's-branch
    }
  });
  return success;
}
<<<<<<< HEAD
function checkFilesForChanges(generated) {
  let hasChanged = false;
  generated.forEach(file => {
    const location = path.join(file.outputDir, file.name);
    const currentContents = fs.readFileSync(location, 'utf8');
    if (currentContents !== file.content) {
      console.error(`- ${file.name} has changed`);
=======

function checkFilesForChanges(map, outputDir) {
  let hasChanged = false;
  map.forEach((contents, fileName) => {
    const location = path.join(outputDir, fileName);
    const currentContents = fs.readFileSync(location, 'utf8');

    if (currentContents !== contents) {
      console.error(`- ${fileName} has changed`);
>>>>>>> origin/Sophia's-branch
      hasChanged = true;
    }
  });
  return !hasChanged;
}
<<<<<<< HEAD
function checkOrWriteFiles(generatedFiles, test) {
  if (test === true) {
    return checkFilesForChanges(generatedFiles);
  }
  return writeMapToFiles(generatedFiles);
}
=======

>>>>>>> origin/Sophia's-branch
module.exports = {
  generate(
    {libraryName, schema, outputDirectory, packageName, assumeNonnull},
    {generators, test},
  ) {
    schemaValidator.validate(schema);
<<<<<<< HEAD
    function composePath(intermediate) {
      return path.join(outputDirectory, intermediate, libraryName);
    }
    const componentIOSOutput = composePath('react/renderer/components/');
    const modulesIOSOutput = composePath('./');
    const outputFoldersForGenerators = {
      componentsIOS: componentIOSOutput,
      modulesIOS: modulesIOSOutput,
      descriptors: outputDirectory,
      events: outputDirectory,
      props: outputDirectory,
      componentsAndroid: outputDirectory,
      modulesAndroid: outputDirectory,
      modulesCxx: outputDirectory,
      tests: outputDirectory,
      'shadow-nodes': outputDirectory,
    };
    const generatedFiles = [];
    for (const name of generators) {
      for (const generator of LIBRARY_GENERATORS[name]) {
        generator(libraryName, schema, packageName, assumeNonnull).forEach(
          (contents, fileName) => {
            generatedFiles.push({
              name: fileName,
              content: contents,
              outputDir: outputFoldersForGenerators[name],
            });
          },
        );
      }
    }
    return checkOrWriteFiles(generatedFiles, test);
  },
=======
    const generatedFiles = [];

    for (const name of generators) {
      for (const generator of LIBRARY_GENERATORS[name]) {
        generatedFiles.push(
          ...generator(libraryName, schema, packageName, assumeNonnull),
        );
      }
    }

    const filesToUpdate = new Map([...generatedFiles]);

    if (test === true) {
      return checkFilesForChanges(filesToUpdate, outputDirectory);
    }

    return writeMapToFiles(filesToUpdate, outputDirectory);
  },

>>>>>>> origin/Sophia's-branch
  generateFromSchemas({schemas, outputDirectory}, {generators, test}) {
    Object.keys(schemas).forEach(libraryName =>
      schemaValidator.validate(schemas[libraryName]),
    );
    const generatedFiles = [];
<<<<<<< HEAD
    for (const name of generators) {
      for (const generator of SCHEMAS_GENERATORS[name]) {
        generator(schemas).forEach((contents, fileName) => {
          generatedFiles.push({
            name: fileName,
            content: contents,
            outputDir: outputDirectory,
          });
        });
      }
    }
    return checkOrWriteFiles(generatedFiles, test);
  },
=======

    for (const name of generators) {
      for (const generator of SCHEMAS_GENERATORS[name]) {
        generatedFiles.push(...generator(schemas));
      }
    }

    const filesToUpdate = new Map([...generatedFiles]);

    if (test === true) {
      return checkFilesForChanges(filesToUpdate, outputDirectory);
    }

    return writeMapToFiles(filesToUpdate, outputDirectory);
  },

>>>>>>> origin/Sophia's-branch
  generateViewConfig({libraryName, schema}) {
    schemaValidator.validate(schema);
    const result = generateViewConfigJs
      .generate(libraryName, schema)
      .values()
      .next();
<<<<<<< HEAD
    if (typeof result.value !== 'string') {
      throw new Error(`Failed to generate view config for ${libraryName}`);
    }
=======

    if (typeof result.value !== 'string') {
      throw new Error(`Failed to generate view config for ${libraryName}`);
    }

>>>>>>> origin/Sophia's-branch
    return result.value;
  },
};
