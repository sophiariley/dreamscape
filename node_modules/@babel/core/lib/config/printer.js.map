<<<<<<< HEAD
{"version":3,"names":["ChainFormatter","Programmatic","Config","Formatter","title","type","callerName","filepath","loc","index","envName","optionsAndDescriptors","opt","content","options","overrides","env","pluginDescriptors","plugins","length","map","d","descriptorToConfig","presetDescriptors","presets","JSON","stringify","undefined","name","file","request","value","toString","slice","ConfigPrinter","_stack","configure","enabled","push","format","config","output","configs","gensync","all","s","join"],"sources":["../../src/config/printer.ts"],"sourcesContent":["import gensync from \"gensync\";\n\nimport type { Handler } from \"gensync\";\n\nimport type {\n  OptionsAndDescriptors,\n  UnloadedDescriptor,\n} from \"./config-descriptors\";\n\n// todo: Use flow enums when @babel/transform-flow-types supports it\nexport const ChainFormatter = {\n  Programmatic: 0,\n  Config: 1,\n};\n\ntype PrintableConfig = {\n  content: OptionsAndDescriptors;\n  type: typeof ChainFormatter[keyof typeof ChainFormatter];\n  callerName: string | undefined | null;\n  filepath: string | undefined | null;\n  index: number | undefined | null;\n  envName: string | undefined | null;\n};\n\nconst Formatter = {\n  title(\n    type: typeof ChainFormatter[keyof typeof ChainFormatter],\n    callerName?: string | null,\n    filepath?: string | null,\n  ): string {\n    let title = \"\";\n    if (type === ChainFormatter.Programmatic) {\n      title = \"programmatic options\";\n      if (callerName) {\n        title += \" from \" + callerName;\n      }\n    } else {\n      title = \"config \" + filepath;\n    }\n    return title;\n  },\n  loc(index?: number | null, envName?: string | null): string {\n    let loc = \"\";\n    if (index != null) {\n      loc += `.overrides[${index}]`;\n    }\n    if (envName != null) {\n      loc += `.env[\"${envName}\"]`;\n    }\n    return loc;\n  },\n\n  *optionsAndDescriptors(opt: OptionsAndDescriptors) {\n    const content = { ...opt.options };\n    // overrides and env will be printed as separated config items\n    delete content.overrides;\n    delete content.env;\n    // resolve to descriptors\n    const pluginDescriptors = [...(yield* opt.plugins())];\n    if (pluginDescriptors.length) {\n      content.plugins = pluginDescriptors.map(d => descriptorToConfig(d));\n    }\n    const presetDescriptors = [...(yield* opt.presets())];\n    if (presetDescriptors.length) {\n      content.presets = [...presetDescriptors].map(d => descriptorToConfig(d));\n    }\n    return JSON.stringify(content, undefined, 2);\n  },\n};\n\nfunction descriptorToConfig(\n  d: UnloadedDescriptor,\n): string | {} | Array<unknown> {\n  let name = d.file?.request;\n  if (name == null) {\n    if (typeof d.value === \"object\") {\n      name = d.value;\n    } else if (typeof d.value === \"function\") {\n      // If the unloaded descriptor is a function, i.e. `plugins: [ require(\"my-plugin\") ]`,\n      // we print the first 50 characters of the function source code and hopefully we can see\n      // `name: 'my-plugin'` in the source\n      name = `[Function: ${d.value.toString().slice(0, 50)} ... ]`;\n    }\n  }\n  if (name == null) {\n    name = \"[Unknown]\";\n  }\n  if (d.options === undefined) {\n    return name;\n  } else if (d.name == null) {\n    return [name, d.options];\n  } else {\n    return [name, d.options, d.name];\n  }\n}\n\nexport class ConfigPrinter {\n  _stack: Array<PrintableConfig> = [];\n  configure(\n    enabled: boolean,\n    type: typeof ChainFormatter[keyof typeof ChainFormatter],\n    {\n      callerName,\n      filepath,\n    }: {\n      callerName?: string;\n      filepath?: string;\n    },\n  ) {\n    if (!enabled) return () => {};\n    return (\n      content: OptionsAndDescriptors,\n      index?: number | null,\n      envName?: string | null,\n    ) => {\n      this._stack.push({\n        type,\n        callerName,\n        filepath,\n        content,\n        index,\n        envName,\n      });\n    };\n  }\n  static *format(config: PrintableConfig): Handler<string> {\n    let title = Formatter.title(\n      config.type,\n      config.callerName,\n      config.filepath,\n    );\n    const loc = Formatter.loc(config.index, config.envName);\n    if (loc) title += ` ${loc}`;\n    const content = yield* Formatter.optionsAndDescriptors(config.content);\n    return `${title}\\n${content}`;\n  }\n\n  *output(): Handler<string> {\n    if (this._stack.length === 0) return \"\";\n    const configs = yield* gensync.all(\n      this._stack.map(s => ConfigPrinter.format(s)),\n    );\n    return configs.join(\"\\n\\n\");\n  }\n}\n"],"mappings":"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"}
=======
{"version":3,"names":["ChainFormatter","Programmatic","Config","Formatter","title","type","callerName","filepath","loc","index","envName","optionsAndDescriptors","opt","content","options","overrides","env","pluginDescriptors","plugins","length","map","d","descriptorToConfig","presetDescriptors","presets","JSON","stringify","undefined","name","file","request","value","toString","slice","ConfigPrinter","_stack","configure","enabled","push","format","config","output","configs","gensync","all","s","join"],"sources":["../../src/config/printer.ts"],"sourcesContent":["import gensync from \"gensync\";\n\nimport type { Handler } from \"gensync\";\n\nimport type {\n  OptionsAndDescriptors,\n  UnloadedDescriptor,\n} from \"./config-descriptors\";\n\n// todo: Use flow enums when @babel/transform-flow-types supports it\nexport const ChainFormatter = {\n  Programmatic: 0,\n  Config: 1,\n};\n\ntype PrintableConfig = {\n  content: OptionsAndDescriptors;\n  type: typeof ChainFormatter[keyof typeof ChainFormatter];\n  callerName: string | undefined | null;\n  filepath: string | undefined | null;\n  index: number | undefined | null;\n  envName: string | undefined | null;\n};\n\nconst Formatter = {\n  title(\n    type: typeof ChainFormatter[keyof typeof ChainFormatter],\n    callerName?: string | null,\n    filepath?: string | null,\n  ): string {\n    let title = \"\";\n    if (type === ChainFormatter.Programmatic) {\n      title = \"programmatic options\";\n      if (callerName) {\n        title += \" from \" + callerName;\n      }\n    } else {\n      title = \"config \" + filepath;\n    }\n    return title;\n  },\n  loc(index?: number | null, envName?: string | null): string {\n    let loc = \"\";\n    if (index != null) {\n      loc += `.overrides[${index}]`;\n    }\n    if (envName != null) {\n      loc += `.env[\"${envName}\"]`;\n    }\n    return loc;\n  },\n\n  *optionsAndDescriptors(opt: OptionsAndDescriptors) {\n    const content = { ...opt.options };\n    // overrides and env will be printed as separated config items\n    delete content.overrides;\n    delete content.env;\n    // resolve to descriptors\n    const pluginDescriptors = [...(yield* opt.plugins())];\n    if (pluginDescriptors.length) {\n      content.plugins = pluginDescriptors.map(d => descriptorToConfig(d));\n    }\n    const presetDescriptors = [...(yield* opt.presets())];\n    if (presetDescriptors.length) {\n      content.presets = [...presetDescriptors].map(d => descriptorToConfig(d));\n    }\n    return JSON.stringify(content, undefined, 2);\n  },\n};\n\nfunction descriptorToConfig(\n  d: UnloadedDescriptor,\n): string | {} | Array<unknown> {\n  let name = d.file?.request;\n  if (name == null) {\n    if (typeof d.value === \"object\") {\n      name = d.value;\n    } else if (typeof d.value === \"function\") {\n      // If the unloaded descriptor is a function, i.e. `plugins: [ require(\"my-plugin\") ]`,\n      // we print the first 50 characters of the function source code and hopefully we can see\n      // `name: 'my-plugin'` in the source\n      name = `[Function: ${d.value.toString().slice(0, 50)} ... ]`;\n    }\n  }\n  if (name == null) {\n    name = \"[Unknown]\";\n  }\n  if (d.options === undefined) {\n    return name;\n  } else if (d.name == null) {\n    return [name, d.options];\n  } else {\n    return [name, d.options, d.name];\n  }\n}\n\nexport class ConfigPrinter {\n  _stack: Array<PrintableConfig> = [];\n  configure(\n    enabled: boolean,\n    type: typeof ChainFormatter[keyof typeof ChainFormatter],\n    {\n      callerName,\n      filepath,\n    }: {\n      callerName?: string;\n      filepath?: string;\n    },\n  ) {\n    if (!enabled) return () => {};\n    return (\n      content: OptionsAndDescriptors,\n      index?: number | null,\n      envName?: string | null,\n    ) => {\n      this._stack.push({\n        type,\n        callerName,\n        filepath,\n        content,\n        index,\n        envName,\n      });\n    };\n  }\n  static *format(config: PrintableConfig): Handler<string> {\n    let title = Formatter.title(\n      config.type,\n      config.callerName,\n      config.filepath,\n    );\n    const loc = Formatter.loc(config.index, config.envName);\n    if (loc) title += ` ${loc}`;\n    const content = yield* Formatter.optionsAndDescriptors(config.content);\n    return `${title}\\n${content}`;\n  }\n\n  *output(): Handler<string> {\n    if (this._stack.length === 0) return \"\";\n    const configs = yield* gensync.all(\n      this._stack.map(s => ConfigPrinter.format(s)),\n    );\n    return configs.join(\"\\n\\n\");\n  }\n}\n"],"mappings":"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"}
>>>>>>> Sophia's-branch
