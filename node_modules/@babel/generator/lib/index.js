"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CodeGenerator = void 0;
exports.default = generate;
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
var _sourceMap = require("./source-map");
=======

<<<<<<< HEAD
var _sourceMap = require("./source-map");

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
var _printer = require("./printer");

class Generator extends _printer.default {
  constructor(ast, opts = {}, code) {
    const format = normalizeOptions(code, opts);
    const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
    super(format, map);
    this.ast = void 0;
    this.ast = ast;
  }

  generate() {
    return super.generate(this.ast);
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
}

function normalizeOptions(code, opts) {
  const format = {
    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
    shouldPrintComment: opts.shouldPrintComment,
    retainLines: opts.retainLines,
    retainFunctionParens: opts.retainFunctionParens,
    comments: opts.comments == null || opts.comments,
    compact: opts.compact,
    minified: opts.minified,
    concise: opts.concise,
    indent: {
      adjustMultilineComment: true,
      style: "  "
    },
    jsescOption: Object.assign({
      quotes: "double",
      wrap: true,
      minimal: false
    }, opts.jsescOption),
    recordAndTupleSyntaxType: opts.recordAndTupleSyntaxType,
    topicToken: opts.topicToken
  };
  {
    format.decoratorsBeforeExport = !!opts.decoratorsBeforeExport;
    format.jsonCompatibleStrings = opts.jsonCompatibleStrings;
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  if (format.minified) {
    format.compact = true;
=======

<<<<<<< HEAD
  if (format.minified) {
    format.compact = true;

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
    format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);
  } else {
    format.shouldPrintComment = format.shouldPrintComment || (value => format.comments || value.includes("@license") || value.includes("@preserve"));
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
  if (format.compact === "auto") {
    format.compact = code.length > 500000;

    if (format.compact) {
      console.error("[BABEL] Note: The code generator has deoptimised the styling of " + `${opts.filename} as it exceeds the max of ${"500KB"}.`);
    }
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  if (format.compact) {
    format.indent.adjustMultilineComment = false;
  }
=======

<<<<<<< HEAD
  if (format.compact) {
    format.indent.adjustMultilineComment = false;
  }

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
  return format;
}

class CodeGenerator {
  constructor(ast, opts, code) {
    this._generator = void 0;
    this._generator = new Generator(ast, opts, code);
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  generate() {
    return this._generator.generate();
  }
}

exports.CodeGenerator = CodeGenerator;
=======

<<<<<<< HEAD
  generate() {
    return this._generator.generate();
  }

}

exports.CodeGenerator = CodeGenerator;

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function generate(ast, opts, code) {
  const gen = new Generator(ast, opts, code);
  return gen.generate();
}

//# sourceMappingURL=index.js.map
