"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnyTypeAnnotation = AnyTypeAnnotation;
exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
exports.DeclareClass = DeclareClass;
exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
exports.DeclareExportDeclaration = DeclareExportDeclaration;
exports.DeclareFunction = DeclareFunction;
exports.DeclareInterface = DeclareInterface;
exports.DeclareModule = DeclareModule;
exports.DeclareModuleExports = DeclareModuleExports;
exports.DeclareOpaqueType = DeclareOpaqueType;
exports.DeclareTypeAlias = DeclareTypeAlias;
exports.DeclareVariable = DeclareVariable;
exports.DeclaredPredicate = DeclaredPredicate;
exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
exports.EnumBooleanBody = EnumBooleanBody;
exports.EnumBooleanMember = EnumBooleanMember;
exports.EnumDeclaration = EnumDeclaration;
exports.EnumDefaultedMember = EnumDefaultedMember;
exports.EnumNumberBody = EnumNumberBody;
exports.EnumNumberMember = EnumNumberMember;
exports.EnumStringBody = EnumStringBody;
exports.EnumStringMember = EnumStringMember;
exports.EnumSymbolBody = EnumSymbolBody;
exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
exports.FunctionTypeParam = FunctionTypeParam;
exports.IndexedAccessType = IndexedAccessType;
exports.InferredPredicate = InferredPredicate;
exports.InterfaceDeclaration = InterfaceDeclaration;
exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
exports.MixedTypeAnnotation = MixedTypeAnnotation;
exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
exports.NullableTypeAnnotation = NullableTypeAnnotation;
Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
  enumerable: true,
  get: function () {
    return _types2.NumericLiteral;
  }
});
exports.NumberTypeAnnotation = NumberTypeAnnotation;
exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
exports.ObjectTypeIndexer = ObjectTypeIndexer;
exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
exports.ObjectTypeProperty = ObjectTypeProperty;
exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
exports.OpaqueType = OpaqueType;
exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
  enumerable: true,
  get: function () {
    return _types2.StringLiteral;
  }
});
exports.StringTypeAnnotation = StringTypeAnnotation;
exports.SymbolTypeAnnotation = SymbolTypeAnnotation;
exports.ThisTypeAnnotation = ThisTypeAnnotation;
exports.TupleTypeAnnotation = TupleTypeAnnotation;
exports.TypeAlias = TypeAlias;
exports.TypeAnnotation = TypeAnnotation;
exports.TypeCastExpression = TypeCastExpression;
exports.TypeParameter = TypeParameter;
exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
exports.UnionTypeAnnotation = UnionTypeAnnotation;
exports.Variance = Variance;
exports.VoidTypeAnnotation = VoidTypeAnnotation;
exports._interfaceish = _interfaceish;
exports._variance = _variance;
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
var _t = require("@babel/types");
var _modules = require("./modules");
var _types2 = require("./types");
=======

<<<<<<< HEAD
var _t = require("@babel/types");

var _modules = require("./modules");

var _types2 = require("./types");

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
const {
  isDeclareExportDeclaration,
  isStatement
} = _t;
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
function AnyTypeAnnotation() {
  this.word("any");
}
=======

<<<<<<< HEAD
function AnyTypeAnnotation() {
  this.word("any");
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function ArrayTypeAnnotation(node) {
  this.print(node.elementType, node, true);
  this.tokenChar(91);
  this.tokenChar(93);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
function BooleanTypeAnnotation() {
  this.word("boolean");
}
function BooleanLiteralTypeAnnotation(node) {
  this.word(node.value ? "true" : "false");
}
function NullLiteralTypeAnnotation() {
  this.word("null");
}
=======

<<<<<<< HEAD
function BooleanTypeAnnotation() {
  this.word("boolean");
}

function BooleanLiteralTypeAnnotation(node) {
  this.word(node.value ? "true" : "false");
}

function NullLiteralTypeAnnotation() {
  this.word("null");
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function DeclareClass(node, parent) {
  if (!isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  this.word("class");
  this.space();
  this._interfaceish(node);
}
=======

<<<<<<< HEAD
  this.word("class");
  this.space();

  this._interfaceish(node);
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function DeclareFunction(node, parent) {
  if (!isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
  this.word("function");
  this.space();
  this.print(node.id, node);
  this.print(node.id.typeAnnotation.typeAnnotation, node);
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
  if (node.predicate) {
    this.space();
    this.print(node.predicate, node);
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  this.semicolon();
}
=======

<<<<<<< HEAD
  this.semicolon();
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function InferredPredicate() {
  this.tokenChar(37);
  this.word("checks");
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function DeclaredPredicate(node) {
  this.tokenChar(37);
  this.word("checks");
  this.tokenChar(40);
  this.print(node.value, node);
  this.tokenChar(41);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function DeclareInterface(node) {
  this.word("declare");
  this.space();
  this.InterfaceDeclaration(node);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function DeclareModule(node) {
  this.word("declare");
  this.space();
  this.word("module");
  this.space();
  this.print(node.id, node);
  this.space();
  this.print(node.body, node);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function DeclareModuleExports(node) {
  this.word("declare");
  this.space();
  this.word("module");
  this.tokenChar(46);
  this.word("exports");
  this.print(node.typeAnnotation, node);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function DeclareTypeAlias(node) {
  this.word("declare");
  this.space();
  this.TypeAlias(node);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function DeclareOpaqueType(node, parent) {
  if (!isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  this.OpaqueType(node);
}
=======

<<<<<<< HEAD
  this.OpaqueType(node);
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function DeclareVariable(node, parent) {
  if (!isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
  this.word("var");
  this.space();
  this.print(node.id, node);
  this.print(node.id.typeAnnotation, node);
  this.semicolon();
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function DeclareExportDeclaration(node) {
  this.word("declare");
  this.space();
  this.word("export");
  this.space();
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
  if (node.default) {
    this.word("default");
    this.space();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  FlowExportDeclaration.call(this, node);
}
function DeclareExportAllDeclaration(node) {
  this.word("declare");
  this.space();
  _modules.ExportAllDeclaration.call(this, node);
}
=======

<<<<<<< HEAD
  FlowExportDeclaration.call(this, node);
}

function DeclareExportAllDeclaration(node) {
  this.word("declare");
  this.space();

  _modules.ExportAllDeclaration.call(this, node);
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function EnumDeclaration(node) {
  const {
    id,
    body
  } = node;
  this.word("enum");
  this.space();
  this.print(id, node);
  this.print(body, node);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function enumExplicitType(context, name, hasExplicitType) {
  if (hasExplicitType) {
    context.space();
    context.word("of");
    context.space();
    context.word(name);
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  context.space();
}
=======

<<<<<<< HEAD
  context.space();
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function enumBody(context, node) {
  const {
    members
  } = node;
  context.token("{");
  context.indent();
  context.newline();
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
  for (const member of members) {
    context.print(member, node);
    context.newline();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
  if (node.hasUnknownMembers) {
    context.token("...");
    context.newline();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  context.dedent();
  context.token("}");
}
=======

<<<<<<< HEAD
  context.dedent();
  context.token("}");
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function EnumBooleanBody(node) {
  const {
    explicitType
  } = node;
  enumExplicitType(this, "boolean", explicitType);
  enumBody(this, node);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function EnumNumberBody(node) {
  const {
    explicitType
  } = node;
  enumExplicitType(this, "number", explicitType);
  enumBody(this, node);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function EnumStringBody(node) {
  const {
    explicitType
  } = node;
  enumExplicitType(this, "string", explicitType);
  enumBody(this, node);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function EnumSymbolBody(node) {
  enumExplicitType(this, "symbol", true);
  enumBody(this, node);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function EnumDefaultedMember(node) {
  const {
    id
  } = node;
  this.print(id, node);
  this.tokenChar(44);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function enumInitializedMember(context, node) {
  const {
    id,
    init
  } = node;
  context.print(id, node);
  context.space();
  context.token("=");
  context.space();
  context.print(init, node);
  context.token(",");
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
function EnumBooleanMember(node) {
  enumInitializedMember(this, node);
}
function EnumNumberMember(node) {
  enumInitializedMember(this, node);
}
function EnumStringMember(node) {
  enumInitializedMember(this, node);
}
=======

<<<<<<< HEAD
function EnumBooleanMember(node) {
  enumInitializedMember(this, node);
}

function EnumNumberMember(node) {
  enumInitializedMember(this, node);
}

function EnumStringMember(node) {
  enumInitializedMember(this, node);
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function FlowExportDeclaration(node) {
  if (node.declaration) {
    const declar = node.declaration;
    this.print(declar, node);
    if (!isStatement(declar)) this.semicolon();
  } else {
    this.tokenChar(123);
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
    if (node.specifiers.length) {
      this.space();
      this.printList(node.specifiers, node);
      this.space();
    }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
    this.tokenChar(125);
=======

<<<<<<< HEAD
    this.tokenChar(125);

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
    if (node.source) {
      this.space();
      this.word("from");
      this.space();
      this.print(node.source, node);
    }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
    this.semicolon();
  }
}
function ExistsTypeAnnotation() {
  this.tokenChar(42);
}
function FunctionTypeAnnotation(node, parent) {
  this.print(node.typeParameters, node);
  this.tokenChar(40);
=======

<<<<<<< HEAD
    this.semicolon();
  }
}

function ExistsTypeAnnotation() {
  this.tokenChar(42);
}

function FunctionTypeAnnotation(node, parent) {
  this.print(node.typeParameters, node);
  this.tokenChar(40);

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
  if (node.this) {
    this.word("this");
    this.tokenChar(58);
    this.space();
    this.print(node.this.typeAnnotation, node);
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
    if (node.params.length || node.rest) {
      this.tokenChar(44);
      this.space();
    }
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  this.printList(node.params, node);
=======

<<<<<<< HEAD
  this.printList(node.params, node);

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
  if (node.rest) {
    if (node.params.length) {
      this.tokenChar(44);
      this.space();
    }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
    this.token("...");
    this.print(node.rest, node);
  }
=======

<<<<<<< HEAD
    this.token("...");
    this.print(node.rest, node);
  }

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
  this.tokenChar(41);

  if (parent && (parent.type === "ObjectTypeCallProperty" || parent.type === "ObjectTypeInternalSlot" || parent.type === "DeclareFunction" || parent.type === "ObjectTypeProperty" && parent.method)) {
    this.tokenChar(58);
  } else {
    this.space();
    this.token("=>");
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  this.space();
  this.print(node.returnType, node);
}
function FunctionTypeParam(node) {
  this.print(node.name, node);
  if (node.optional) this.tokenChar(63);
=======

<<<<<<< HEAD
  this.space();
  this.print(node.returnType, node);
}

function FunctionTypeParam(node) {
  this.print(node.name, node);
  if (node.optional) this.tokenChar(63);

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
  if (node.name) {
    this.tokenChar(58);
    this.space();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  this.print(node.typeAnnotation, node);
}
=======

<<<<<<< HEAD
  this.print(node.typeAnnotation, node);
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function InterfaceExtends(node) {
  this.print(node.id, node);
  this.print(node.typeParameters, node, true);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
function _interfaceish(node) {
  var _node$extends;
  this.print(node.id, node);
  this.print(node.typeParameters, node);
=======

<<<<<<< HEAD
function _interfaceish(node) {
  var _node$extends;

  this.print(node.id, node);
  this.print(node.typeParameters, node);

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
  if ((_node$extends = node.extends) != null && _node$extends.length) {
    this.space();
    this.word("extends");
    this.space();
    this.printList(node.extends, node);
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
  if (node.mixins && node.mixins.length) {
    this.space();
    this.word("mixins");
    this.space();
    this.printList(node.mixins, node);
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
  if (node.implements && node.implements.length) {
    this.space();
    this.word("implements");
    this.space();
    this.printList(node.implements, node);
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  this.space();
  this.print(node.body, node);
}
=======

<<<<<<< HEAD
  this.space();
  this.print(node.body, node);
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function _variance(node) {
  if (node.variance) {
    if (node.variance.kind === "plus") {
      this.tokenChar(43);
    } else if (node.variance.kind === "minus") {
      this.tokenChar(45);
    }
  }
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
function InterfaceDeclaration(node) {
  this.word("interface");
  this.space();
  this._interfaceish(node);
}
=======

<<<<<<< HEAD
function InterfaceDeclaration(node) {
  this.word("interface");
  this.space();

  this._interfaceish(node);
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function andSeparator() {
  this.space();
  this.tokenChar(38);
  this.space();
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
function InterfaceTypeAnnotation(node) {
  this.word("interface");
=======

<<<<<<< HEAD
function InterfaceTypeAnnotation(node) {
  this.word("interface");

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
  if (node.extends && node.extends.length) {
    this.space();
    this.word("extends");
    this.space();
    this.printList(node.extends, node);
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  this.space();
  this.print(node.body, node);
}
=======

<<<<<<< HEAD
  this.space();
  this.print(node.body, node);
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function IntersectionTypeAnnotation(node) {
  this.printJoin(node.types, node, {
    separator: andSeparator
  });
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
function MixedTypeAnnotation() {
  this.word("mixed");
}
function EmptyTypeAnnotation() {
  this.word("empty");
}
=======

<<<<<<< HEAD
function MixedTypeAnnotation() {
  this.word("mixed");
}

function EmptyTypeAnnotation() {
  this.word("empty");
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function NullableTypeAnnotation(node) {
  this.tokenChar(63);
  this.print(node.typeAnnotation, node);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
function NumberTypeAnnotation() {
  this.word("number");
}
function StringTypeAnnotation() {
  this.word("string");
}
function ThisTypeAnnotation() {
  this.word("this");
}
=======

<<<<<<< HEAD
function NumberTypeAnnotation() {
  this.word("number");
}

function StringTypeAnnotation() {
  this.word("string");
}

function ThisTypeAnnotation() {
  this.word("this");
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function TupleTypeAnnotation(node) {
  this.tokenChar(91);
  this.printList(node.types, node);
  this.tokenChar(93);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function TypeofTypeAnnotation(node) {
  this.word("typeof");
  this.space();
  this.print(node.argument, node);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function TypeAlias(node) {
  this.word("type");
  this.space();
  this.print(node.id, node);
  this.print(node.typeParameters, node);
  this.space();
  this.tokenChar(61);
  this.space();
  this.print(node.right, node);
  this.semicolon();
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function TypeAnnotation(node) {
  this.tokenChar(58);
  this.space();
  if (node.optional) this.tokenChar(63);
  this.print(node.typeAnnotation, node);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function TypeParameterInstantiation(node) {
  this.tokenChar(60);
  this.printList(node.params, node, {});
  this.tokenChar(62);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
function TypeParameter(node) {
  this._variance(node);
  this.word(node.name);
  if (node.bound) {
    this.print(node.bound, node);
  }
=======

<<<<<<< HEAD
function TypeParameter(node) {
  this._variance(node);

  this.word(node.name);

  if (node.bound) {
    this.print(node.bound, node);
  }

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
  if (node.default) {
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.default, node);
  }
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function OpaqueType(node) {
  this.word("opaque");
  this.space();
  this.word("type");
  this.space();
  this.print(node.id, node);
  this.print(node.typeParameters, node);
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
  if (node.supertype) {
    this.tokenChar(58);
    this.space();
    this.print(node.supertype, node);
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
  if (node.impltype) {
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.impltype, node);
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  this.semicolon();
}
=======

<<<<<<< HEAD
  this.semicolon();
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function ObjectTypeAnnotation(node) {
  if (node.exact) {
    this.token("{|");
  } else {
    this.tokenChar(123);
  }

  const props = [...node.properties, ...(node.callProperties || []), ...(node.indexers || []), ...(node.internalSlots || [])];
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
  if (props.length) {
    this.newline();
    this.space();
    this.printJoin(props, node, {
      addNewlines(leading) {
        if (leading && !props[0]) return 1;
      },
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
      indent: true,
      statement: true,
      iterator: () => {
        if (props.length !== 1 || node.inexact) {
          this.tokenChar(44);
          this.space();
        }
      }
    });
    this.space();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  if (node.inexact) {
    this.indent();
    this.token("...");
    if (props.length) {
      this.newline();
    }
    this.dedent();
  }
=======

<<<<<<< HEAD
  if (node.inexact) {
    this.indent();
    this.token("...");

    if (props.length) {
      this.newline();
    }

    this.dedent();
  }

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
  if (node.exact) {
    this.token("|}");
  } else {
    this.tokenChar(125);
  }
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function ObjectTypeInternalSlot(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
  this.tokenChar(91);
  this.tokenChar(91);
  this.print(node.id, node);
  this.tokenChar(93);
  this.tokenChar(93);
  if (node.optional) this.tokenChar(63);
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
  if (!node.method) {
    this.tokenChar(58);
    this.space();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  this.print(node.value, node);
}
=======

<<<<<<< HEAD
  this.print(node.value, node);
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function ObjectTypeCallProperty(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  this.print(node.value, node);
}
=======

<<<<<<< HEAD
  this.print(node.value, node);
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function ObjectTypeIndexer(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  this._variance(node);
  this.tokenChar(91);
=======

<<<<<<< HEAD
  this._variance(node);

  this.tokenChar(91);

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
  if (node.id) {
    this.print(node.id, node);
    this.tokenChar(58);
    this.space();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
  this.print(node.key, node);
  this.tokenChar(93);
  this.tokenChar(58);
  this.space();
  this.print(node.value, node);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function ObjectTypeProperty(node) {
  if (node.proto) {
    this.word("proto");
    this.space();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
  if (node.static) {
    this.word("static");
    this.space();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
  if (node.kind === "get" || node.kind === "set") {
    this.word(node.kind);
    this.space();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  this._variance(node);
  this.print(node.key, node);
  if (node.optional) this.tokenChar(63);
=======

<<<<<<< HEAD
  this._variance(node);

  this.print(node.key, node);
  if (node.optional) this.tokenChar(63);

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
  if (!node.method) {
    this.tokenChar(58);
    this.space();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
  this.print(node.value, node);
}
=======

<<<<<<< HEAD
  this.print(node.value, node);
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function ObjectTypeSpreadProperty(node) {
  this.token("...");
  this.print(node.argument, node);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function QualifiedTypeIdentifier(node) {
  this.print(node.qualification, node);
  this.tokenChar(46);
  this.print(node.id, node);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
function SymbolTypeAnnotation() {
  this.word("symbol");
}
=======

<<<<<<< HEAD
function SymbolTypeAnnotation() {
  this.word("symbol");
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function orSeparator() {
  this.space();
  this.tokenChar(124);
  this.space();
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function UnionTypeAnnotation(node) {
  this.printJoin(node.types, node, {
    separator: orSeparator
  });
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function TypeCastExpression(node) {
  this.tokenChar(40);
  this.print(node.expression, node);
  this.print(node.typeAnnotation, node);
  this.tokenChar(41);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin/Sophia's-branch
=======

>>>>>>> origin
function Variance(node) {
  if (node.kind === "plus") {
    this.tokenChar(43);
  } else {
    this.tokenChar(45);
  }
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
function VoidTypeAnnotation() {
  this.word("void");
}
=======

<<<<<<< HEAD
function VoidTypeAnnotation() {
  this.word("void");
}

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
function IndexedAccessType(node) {
  this.print(node.objectType, node, true);
  this.tokenChar(91);
  this.print(node.indexType, node);
  this.tokenChar(93);
}
<<<<<<< HEAD
<<<<<<< HEAD
=======

>>>>>>> origin
function OptionalIndexedAccessType(node) {
  this.print(node.objectType, node);
  if (node.optional) {
    this.token("?.");
  }
=======

<<<<<<< HEAD
function OptionalIndexedAccessType(node) {
  this.print(node.objectType, node);

  if (node.optional) {
    this.token("?.");
  }

>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
  this.tokenChar(91);
  this.print(node.indexType, node);
  this.tokenChar(93);
}

//# sourceMappingURL=flow.js.map
