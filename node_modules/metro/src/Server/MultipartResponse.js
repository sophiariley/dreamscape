/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
<<<<<<< HEAD
<<<<<<< HEAD
 *
=======
>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
 * @format
 */
"use strict";

const accepts = require("accepts");

const CRLF = "\r\n";
const BOUNDARY = "3beqjf3apnqeu3h5jqorms4i";

class MultipartResponse {
<<<<<<< HEAD
<<<<<<< HEAD
  static wrapIfSupported(req, res) {
    if (accepts(req).types().includes("multipart/mixed")) {
      return new MultipartResponse(res);
    }
=======
  static wrap(req, res) {
    if (accepts(req).types().includes("multipart/mixed")) {
      return new MultipartResponse(res);
    } // Ugly hack, ideally wrap function should always return a proxy
    // object with the same interface

    res.writeChunk = () => {}; // noop
>>>>>>> origin

    return res;
  }

<<<<<<< HEAD
  static serializeHeaders(headers) {
    return Object.keys(headers)
      .map((key) => `${key}: ${headers[key]}`)
      .join(CRLF);
=======
  static wrap(req, res) {
    if (accepts(req).types().includes("multipart/mixed")) {
      return new MultipartResponse(res);
    } // Ugly hack, ideally wrap function should always return a proxy
    // object with the same interface

    res.writeChunk = () => {}; // noop

    return res;
>>>>>>> origin/Sophia's-branch
  }

=======
>>>>>>> origin
  constructor(res) {
    this.res = res;
    this.headers = {};
    res.writeHead(200, {
      "Content-Type": `multipart/mixed; boundary="${BOUNDARY}"`,
    });
    res.write(
      "If you are seeing this, your client does not support multipart response"
    );
  }

  writeChunk(headers, data, isLast = false) {
    if (this.res.finished) {
      return;
    }

    this.res.write(`${CRLF}--${BOUNDARY}${CRLF}`);

    if (headers) {
      this.res.write(MultipartResponse.serializeHeaders(headers) + CRLF + CRLF);
    }

<<<<<<< HEAD
<<<<<<< HEAD
    if (data != null) {
=======
    if (data) {
>>>>>>> origin/Sophia's-branch
=======
    if (data) {
>>>>>>> origin
      this.res.write(data);
    }

    if (isLast) {
      this.res.write(`${CRLF}--${BOUNDARY}--${CRLF}`);
    }
  }

  writeHead(status, headers) {
    // We can't actually change the response HTTP status code
    // because the headers have already been sent
    this.setHeader("X-Http-Status", status);

    if (!headers) {
      return;
    }

    for (const key in headers) {
      this.setHeader(key, headers[key]);
    }
  }

  setHeader(name, value) {
    this.headers[name] = value;
  }

  end(data) {
    this.writeChunk(this.headers, data, true);
    this.res.end();
  }
<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
>>>>>>> origin

  static serializeHeaders(headers) {
    return Object.keys(headers)
      .map((key) => `${key}: ${headers[key]}`)
      .join(CRLF);
  }
<<<<<<< HEAD
>>>>>>> origin/Sophia's-branch
=======
>>>>>>> origin
}

module.exports = MultipartResponse;
