/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow strict-local
 * @format
 */

'use strict';

<<<<<<< HEAD
import type {RequireContextParams} from '../ModuleGraph/worker/collectDependencies';
import type {RequireContext} from '../lib/contextModule';
import type {PrivateState} from './graphOperations';
import type {JsTransformOptions} from 'metro-transform-worker';

import CountingSet from '../lib/CountingSet';

export type MixedOutput = {
  +data: mixed,
  +type: string,
};

export type AsyncDependencyType = 'async' | 'prefetch';

export type TransformResultDependency = {
=======
import type {JsTransformOptions} from 'metro-transform-worker';

export type MixedOutput = {|
  +data: mixed,
  +type: string,
|};

export type AsyncDependencyType = 'async' | 'prefetch';

export type TransformResultDependency = {|
>>>>>>> Sophia's-branch
  /**
   * The literal name provided to a require or import call. For example 'foo' in
   * case of `require('foo')`.
   */
  +name: string,

  /**
<<<<<<< HEAD
   * Extra data returned by the dependency extractor.
   */
  +data: {
    /**
     * A locally unique key for this dependency within the current module.
     */
    +key: string,
=======
   * Extra data returned by the dependency extractor. Whatever is added here is
   * blindly piped by Metro to the serializers.
   */
  +data: {|
>>>>>>> Sophia's-branch
    /**
     * If not null, this dependency is due to a dynamic `import()` or `__prefetchImport()` call.
     */
    +asyncType: AsyncDependencyType | null,
    /**
     * The condition for splitting on this dependency edge.
     */
<<<<<<< HEAD
    +splitCondition?: {
      +mobileConfigName: string,
    },
=======
    +splitCondition?: {|
      +mobileConfigName: string,
    |},
>>>>>>> Sophia's-branch
    /**
     * The dependency is enclosed in a try/catch block.
     */
    +isOptional?: boolean,

    +locs: $ReadOnlyArray<BabelSourceLocation>,
<<<<<<< HEAD

    /** Context for requiring a collection of modules. */
    +contextParams?: RequireContextParams,
  },
};

export type Dependency = {
  +absolutePath: string,
  +data: TransformResultDependency,
};

export type Module<T = MixedOutput> = {
  +dependencies: Map<string, Dependency>,
  +inverseDependencies: CountingSet<string>,
  +output: $ReadOnlyArray<T>,
  +path: string,
  +getSource: () => Buffer,
};
=======
  |},
|};

export type Dependency = {|
  +absolutePath: string,
  +data: TransformResultDependency,
|};

export type Module<T = MixedOutput> = {|
  +dependencies: Map<string, Dependency>,
  +inverseDependencies: Set<string>,
  +output: $ReadOnlyArray<T>,
  +path: string,
  +getSource: () => Buffer,
|};
>>>>>>> Sophia's-branch

export type Dependencies<T = MixedOutput> = Map<string, Module<T>>;

export type TransformInputOptions = $Diff<
  JsTransformOptions,
  {
    inlinePlatform: boolean,
    inlineRequires: boolean,
    ...
  },
>;

<<<<<<< HEAD
export type GraphInputOptions = $ReadOnly<{
  entryPoints: $ReadOnlySet<string>,
  // Unused in core but useful for custom serializers / experimentalSerializerHook
  transformOptions: TransformInputOptions,
}>;

export type Graph<T = MixedOutput> = {
  ...$ReadOnly<GraphInputOptions>,
  dependencies: Dependencies<T>,
  +importBundleNames: Set<string>,
  +privateState: PrivateState,
};

export type TransformResult<T = MixedOutput> = $ReadOnly<{
  dependencies: $ReadOnlyArray<TransformResultDependency>,
  output: $ReadOnlyArray<T>,
}>;

export type TransformResultWithSource<T = MixedOutput> = $ReadOnly<{
  ...TransformResult<T>,
  getSource: () => Buffer,
}>;

export type TransformFn<T = MixedOutput> = (
  string,
  ?RequireContext,
) => Promise<TransformResultWithSource<T>>;
export type AllowOptionalDependenciesWithOptions = {
  +exclude: Array<string>,
};
=======
export type Graph<T = MixedOutput> = {|
  dependencies: Dependencies<T>,
  importBundleNames: Set<string>,
  +entryPoints: $ReadOnlyArray<string>,
  // Unused in core but useful for custom serializers / experimentalSerializerHook
  +transformOptions: TransformInputOptions,
|};

export type TransformResult<T = MixedOutput> = $ReadOnly<{|
  dependencies: $ReadOnlyArray<TransformResultDependency>,
  output: $ReadOnlyArray<T>,
|}>;

export type TransformResultWithSource<T = MixedOutput> = $ReadOnly<{|
  ...TransformResult<T>,
  getSource: () => Buffer,
|}>;

export type TransformFn<T = MixedOutput> = string => Promise<
  TransformResultWithSource<T>,
>;
export type AllowOptionalDependenciesWithOptions = {|
  +exclude: Array<string>,
|};
>>>>>>> Sophia's-branch
export type AllowOptionalDependencies =
  | boolean
  | AllowOptionalDependenciesWithOptions;

<<<<<<< HEAD
export type Options<T = MixedOutput> = {
=======
export type Options<T = MixedOutput> = {|
>>>>>>> Sophia's-branch
  +resolve: (from: string, to: string) => string,
  +transform: TransformFn<T>,
  +transformOptions: TransformInputOptions,
  +onProgress: ?(numProcessed: number, total: number) => mixed,
  +experimentalImportBundleSupport: boolean,
<<<<<<< HEAD
  +unstable_allowRequireContext: boolean,
  +shallow: boolean,
};

export type DeltaResult<T = MixedOutput> = {
=======
  +shallow: boolean,
|};

export type DeltaResult<T = MixedOutput> = {|
>>>>>>> Sophia's-branch
  +added: Map<string, Module<T>>,
  +modified: Map<string, Module<T>>,
  +deleted: Set<string>,
  +reset: boolean,
<<<<<<< HEAD
};

export type SerializerOptions = {
=======
|};

export type SerializerOptions = {|
>>>>>>> Sophia's-branch
  +asyncRequireModulePath: string,
  +createModuleId: string => number,
  +dev: boolean,
  +getRunModuleStatement: (number | string) => string,
  +inlineSourceMap: ?boolean,
  +modulesOnly: boolean,
  +processModuleFilter: (module: Module<>) => boolean,
  +projectRoot: string,
  +runBeforeMainModule: $ReadOnlyArray<string>,
  +runModule: boolean,
  +serverRoot: string,
  +sourceMapUrl: ?string,
  +sourceUrl: ?string,
<<<<<<< HEAD
};
=======
|};
>>>>>>> Sophia's-branch
