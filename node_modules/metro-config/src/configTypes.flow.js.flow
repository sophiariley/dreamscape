/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 * @flow strict-local
 */

'use strict';

import type {IncomingMessage, ServerResponse} from 'http';
import type {CacheStore} from 'metro-cache';
import typeof MetroCache from 'metro-cache';
<<<<<<< HEAD
import type {CacheManagerFactory} from 'metro-file-map';
=======
>>>>>>> Sophia's-branch
import type {CustomResolver} from 'metro-resolver';
import type {MixedSourceMap} from 'metro-source-map';
import type {JsTransformerConfig} from 'metro-transform-worker';
import type {TransformResult} from 'metro/src/DeltaBundler';
import type {
  DeltaResult,
  Graph,
  Module,
  SerializerOptions,
} from 'metro/src/DeltaBundler/types.flow.js';
import type {Reporter} from 'metro/src/lib/reporting';
import type {TransformVariants} from 'metro/src/ModuleGraph/types.flow.js';
import type Server from 'metro/src/Server';

export type PostProcessBundleSourcemap = ({
  code: Buffer | string,
  map: MixedSourceMap,
  outFileName: string,
  ...
}) => {
  code: Buffer | string,
  map: MixedSourceMap | string,
  ...
};

type ExtraTransformOptions = {
  +preloadedModules: {[path: string]: true, ...} | false,
  +ramGroups: Array<string>,
<<<<<<< HEAD
  +transform: {
=======
  +transform: {|
>>>>>>> Sophia's-branch
    +experimentalImportSupport: boolean,
    +inlineRequires: {+blockList: {[string]: true, ...}, ...} | boolean,
    +nonInlinedRequires?: $ReadOnlyArray<string>,
    +unstable_disableES6Transforms?: boolean,
<<<<<<< HEAD
  },
  ...
};

export type GetTransformOptionsOpts = {
  dev: boolean,
  hot: boolean,
  platform: ?string,
};
=======
  |},
  ...
};

export type GetTransformOptionsOpts = {|
  dev: boolean,
  hot: boolean,
  platform: ?string,
|};
>>>>>>> Sophia's-branch

export type GetTransformOptions = (
  entryPoints: $ReadOnlyArray<string>,
  options: GetTransformOptionsOpts,
  getDependenciesOf: (string) => Promise<Array<string>>,
) => Promise<ExtraTransformOptions>;

export type Middleware = (
  IncomingMessage,
  ServerResponse,
  ((e: ?Error) => mixed),
) => mixed;

<<<<<<< HEAD
type PerfAnnotations = $Shape<{
  string: {[key: string]: string},
  int: {[key: string]: number},
  double: {[key: string]: number},
  bool: {[key: string]: boolean},
  string_array: {[key: string]: Array<string>},
  int_array: {[key: string]: Array<number>},
  double_array: {[key: string]: Array<number>},
  bool_array: {[key: string]: Array<boolean>},
}>;

export interface PerfLogger {
  point(name: string): void;
  annotate(annotations: PerfAnnotations): void;
  subSpan(label: string): PerfLogger;
}

type ResolverConfigT = {
=======
type ResolverConfigT = {|
>>>>>>> Sophia's-branch
  assetExts: $ReadOnlyArray<string>,
  assetResolutions: $ReadOnlyArray<string>,
  blacklistRE?: RegExp | Array<RegExp>,
  blockList: RegExp | Array<RegExp>,
  disableHierarchicalLookup: boolean,
  dependencyExtractor: ?string,
  emptyModulePath: string,
  extraNodeModules: {[name: string]: string, ...},
  hasteImplModulePath: ?string,
<<<<<<< HEAD
=======
  unstable_hasteMapModulePath: ?string,
>>>>>>> Sophia's-branch
  nodeModulesPaths: $ReadOnlyArray<string>,
  platforms: $ReadOnlyArray<string>,
  resolveRequest: ?CustomResolver,
  resolverMainFields: $ReadOnlyArray<string>,
  sourceExts: $ReadOnlyArray<string>,
  useWatchman: boolean,
<<<<<<< HEAD
  requireCycleIgnorePatterns: $ReadOnlyArray<RegExp>,
};

type SerializerConfigT = {
=======
|};

type SerializerConfigT = {|
>>>>>>> Sophia's-branch
  createModuleIdFactory: () => (path: string) => number,
  customSerializer: ?(
    entryPoint: string,
    preModules: $ReadOnlyArray<Module<>>,
    graph: Graph<>,
    options: SerializerOptions,
<<<<<<< HEAD
  ) => Promise<string | {code: string, map: string}>,
=======
  ) => Promise<string | {|code: string, map: string|}>,
>>>>>>> Sophia's-branch
  experimentalSerializerHook: (graph: Graph<>, delta: DeltaResult<>) => mixed,
  getModulesRunBeforeMainModule: (entryFilePath: string) => Array<string>,
  getPolyfills: ({platform: ?string, ...}) => $ReadOnlyArray<string>,
  getRunModuleStatement: (number | string) => string,
  polyfillModuleNames: $ReadOnlyArray<string>,
  postProcessBundleSourcemap: PostProcessBundleSourcemap,
  processModuleFilter: (modules: Module<>) => boolean,
<<<<<<< HEAD
};

type TransformerConfigT = {
=======
|};

type TransformerConfigT = {|
>>>>>>> Sophia's-branch
  ...JsTransformerConfig,
  getTransformOptions: GetTransformOptions,
  transformVariants: TransformVariants,
  workerPath: string,
  publicPath: string,
  experimentalImportBundleSupport: boolean,
<<<<<<< HEAD
};

type MetalConfigT = {
  cacheStores: $ReadOnlyArray<CacheStore<TransformResult<>>>,
  cacheVersion: string,
  fileMapCacheDirectory?: string,
  hasteMapCacheDirectory?: string, // Deprecated, alias of fileMapCacheDirectory
  unstable_fileMapCacheManagerFactory?: CacheManagerFactory,
  maxWorkers: number,
  unstable_perfLogger?: ?PerfLogger,
=======
|};

type MetalConfigT = {|
  cacheStores: $ReadOnlyArray<CacheStore<TransformResult<>>>,
  cacheVersion: string,
  hasteMapCacheDirectory?: string,
  maxWorkers: number,
>>>>>>> Sophia's-branch
  projectRoot: string,
  stickyWorkers: boolean,
  transformerPath: string,
  reporter: Reporter,
  resetCache: boolean,
  watchFolders: $ReadOnlyArray<string>,
<<<<<<< HEAD
};

type ServerConfigT = {
=======
|};

type ServerConfigT = {|
>>>>>>> Sophia's-branch
  enhanceMiddleware: (Middleware, Server) => Middleware,
  useGlobalHotkey: boolean,
  port: number,
  unstable_serverRoot: ?string,
  rewriteRequestUrl: string => string,
  runInspectorProxy: boolean,
  verifyConnections: boolean,
<<<<<<< HEAD
};

type SymbolicatorConfigT = {
=======
|};

type SymbolicatorConfigT = {|
>>>>>>> Sophia's-branch
  customizeFrame: ({
    +file: ?string,
    +lineNumber: ?number,
    +column: ?number,
    +methodName: ?string,
    ...
<<<<<<< HEAD
  }) => ?{+collapse?: boolean} | Promise<?{+collapse?: boolean}>,
};

type WatcherConfigT = {
  additionalExts: $ReadOnlyArray<string>,
  watchman: {
    deferStates: $ReadOnlyArray<string>,
  },
};

export type InputConfigT = $Shape<{
  ...MetalConfigT,
  ...$ReadOnly<{
=======
  }) => ?{|+collapse?: boolean|} | Promise<?{|+collapse?: boolean|}>,
|};

export type InputConfigT = $Shape<{|
  ...MetalConfigT,
  ...$ReadOnly<{|
>>>>>>> Sophia's-branch
    cacheStores:
      | $ReadOnlyArray<CacheStore<TransformResult<>>>
      | (MetroCache => $ReadOnlyArray<CacheStore<TransformResult<>>>),
    resolver: $Shape<ResolverConfigT>,
    server: $Shape<ServerConfigT>,
    serializer: $Shape<SerializerConfigT>,
    symbolicator: $Shape<SymbolicatorConfigT>,
    transformer: $Shape<TransformerConfigT>,
<<<<<<< HEAD
    watcher: $Shape<WatcherConfigT>,
  }>,
}>;

export type IntermediateConfigT = {
  ...MetalConfigT,
  ...{
=======
  |}>,
|}>;

export type IntermediateConfigT = {|
  ...MetalConfigT,
  ...{|
>>>>>>> Sophia's-branch
    resolver: ResolverConfigT,
    server: ServerConfigT,
    serializer: SerializerConfigT,
    symbolicator: SymbolicatorConfigT,
    transformer: TransformerConfigT,
<<<<<<< HEAD
    watcher: WatcherConfigT,
  },
};

export type ConfigT = $ReadOnly<{
  ...$ReadOnly<MetalConfigT>,
  ...$ReadOnly<{
=======
  |},
|};

export type ConfigT = $ReadOnly<{|
  ...$ReadOnly<MetalConfigT>,
  ...$ReadOnly<{|
>>>>>>> Sophia's-branch
    resolver: $ReadOnly<ResolverConfigT>,
    server: $ReadOnly<ServerConfigT>,
    serializer: $ReadOnly<SerializerConfigT>,
    symbolicator: $ReadOnly<SymbolicatorConfigT>,
    transformer: $ReadOnly<TransformerConfigT>,
<<<<<<< HEAD
    watcher: $ReadOnly<WatcherConfigT>,
  }>,
}>;
=======
  |}>,
|}>;
>>>>>>> Sophia's-branch

export type YargArguments = {
  config?: string,
  cwd?: string,
  port?: string | number,
  host?: string,
  projectRoot?: string,
  watchFolders?: Array<string>,
  assetExts?: Array<string>,
  sourceExts?: Array<string>,
  platforms?: Array<string>,
  'max-workers'?: string | number,
  maxWorkers?: string | number,
  transformer?: string,
  'reset-cache'?: boolean,
  resetCache?: boolean,
  runInspectorProxy?: boolean,
  verbose?: boolean,
  ...
};
